## 减少 HTTP 请求

##### 图片地图

允许在一个图片上关联多个URL.通过html的map标签实现



##### CSS Sprites

也是 将多个图片足组合成一个图片。通过css的background-position属性将HTML元素放置到背景图片中期望的位置上。



##### 内联图片

通过使用 data:URL 模式可以在Web页面中包含图片但无需任何额外的HTTP请求。

格式 `data:[<mediatype>][;base64],<data>`

一个红色五角星形状的内敛图片可以定义为

`<img alt="red star" src="data:image/gif;base64,xxxxxxxxsafxxxxxxxfsfdasdfasdf="/>`



##### 合并脚本和样式表

将一些单独的文件合并到一个文件中，类似CSS sprites可以减少HTTP请求的数量

脚本不要和样式表合并在一起，多个脚本合并成一个脚本，多个样式表合并成一个样式表。



## 使用内容发布网络

内容发布网络是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。

除了缩短响应时间外，CDN还可以带来其他优势。他们的服务包括备份、扩展存储能力和进行缓存。

我们经常把一些比较频繁请求且容量比较大的文件，并且更新频率不那么高的文件放在CDN



## 使用缓存

长久的Expires头应E该包含任何不经常变化的组件，包含脚本、样式表和Flash组件。但是HTML文档不应该使用长久的Expires头，因为它包含动态内容，这些内容在每次用户请求时都将被更新。

当我们刷新页面后，一些资源不是从服务器拿取，而是显示memory cache ,disk cache

memory cache 是内存中的缓存，主要包含当前页面中已经下载的资源，比如样式、脚本、图片等。读取速度快，但是关闭页面后，内存中的缓存就被释放了

disk cache 是磁盘中的缓存，读取速度要慢一点，但是所有资源文件都可以存在磁盘中。会根据 http header 中的字段判断哪些资源需要缓存，哪些资源已经过期要重新请求。一般，大的文件和使用频率较高的文件会优先放到磁盘。

##### 强缓存

强缓存是不会向服务器发送请求，直接从缓存中读取资源。是通过`Expires` 和 `Cache-Control`来实现的。

expires 响应头通过 expires 告诉浏览器在过期时间内直接可以从缓存中读取数据。但是如果修改了本地时间，可能造成缓存失效。

cache-control 当同时拥有expires和cache-control，cache-control优先。

* Cache-Control：max-age =300 在这个请求的五分钟之内再次加载该资源时，可以直接从缓存中读取
* Cache-Control:public 该资源可以在任何地方被缓存
* Cache-Control:private 该资源只可以被浏览器缓存
* Cache-Control:no-store 浏览器每次都要从服务器拿资源，真正的数据不缓存在本地
* Cache-Control:no-cache 要使用的缓存文件每次都要和服务器确认是最新的文件才能使用
* Cache-Control:s-maxage = 60 覆盖max-age ，作用一样，只在代理服务器中生效
* Cache-Control:must-revalidate 表示只有校验缓存里是最新文件才能用缓存里的版本
* Cache-Control:max-stale=30 能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）
* Cache-Control:max-fresh=30 能够容忍的最小新鲜度，min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应

##### 协商缓存

是指强缓存的资源失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存。

缓存有效，返回304和Not Modified。浏览器从缓存中读取资源

缓存失效，返回200和请求结果。

协商缓存利用 [Last-Modified,If-Modified-Since] [ETag,If-None-Match] 这两对header管理。

* Last-Modified,If-Modified-Since

  浏览器第一次访问该资源时，服务器会在响应头中加入Last-Modified的值，表示这个资源在服务器的最后修改时间。浏览器在下一次请求该资源时，检测到有Last-Modified字段时，就会在请求头加入If-Modified-Since,服务器会根据If-Modified-Since和服务器上的这个资源的最后修改资源进行对比。

  弊端：如果本地打开缓存文件，即使没有修改，还是会导致Last-Modified被修改。Last-Modified只能以秒计时，如果快速修改，那么服务器上的资源被修改了，但是Last-Modified不变

  

* ETag,If-None-Match

  返回当前资源文件的唯一标识（由服务器生成）

ETag 优先级高

##### 总结

强缓存优先协商缓存，若强缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存([Last-Modified/If-Modified-Since],[ETag/If-None-Match])，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中，生效则返回304，继续使用缓存。

[![UbajFx.png](https://s1.ax1x.com/2020/07/22/UbajFx.png)](https://imgchr.com/i/UbajFx)

##### 用户行为对浏览器缓存的影响

指用户在浏览器如何操作时，会触发怎样的缓存策略

* 打开网页，输入地址，查找disk cache中是否匹配，如有则使用，没有发送网络请求
* 普通刷新，由于网页没有关闭，因此memory cache可用，会被优先使用，其次时disk cache
* 强制刷新，浏览器不使用缓存，此时发送的请求头均带有 cache-control:no-cache 服务器返回最新资源



## 压缩组件

web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持

`Accept-Encoding:gzip,deflate`

如果 web 服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来压缩响应。web 服务器通过响应中的 Content-Encoding 头来通知 web 客户端

`Content-Encoding:gzip`



##### 代理缓存

当浏览器直接和服务器通信时，服务器基于Accept-Encoding 来检测是否对响应进行压缩，然后返回数据。

但是当浏览器发送请求给代理服务器时，情况会比较复杂。当请求的URL和请求方法相同时，浏览器会读取相同的缓存，但是这个缓存映射的可能是压缩或者没有压缩的数据，所以我们需要使用vary进行区分。这里有一个例子

假设客户端 A 请求了一个数据，且该客户端支持 gzip 压缩，于是请求头字段中带有 Accept-Encoding: gzip。

请求来到了代理服务器，但是里面没有缓存，所以代理服务器把请求又发送给了源服务器。源服务器拿到了请求报文，分析了一波，决定返回一个进行了 gzip 压缩的数据。另外，源服务器还希望介于它和客户端之间的代理服务器，也那能够像它一样优秀，可以根据 Accept-Encoding 返回正确的数据，于是在响应头字段中加上了 Vary: Accept-Encoding，并返回了数据A 给代理服务器。

数据A 来到了代理服务器，代理服务器取出了 Vary 字段，发现里面有个 Accept-Encoding，于是它明白了，它需要将当前响应报文的 Accept-Encoding 作为一个标志，映射到当前这个缓存数据A。即：`URL + 请求方法 + "Accept-Encoding: gzip" -> 数据A`
代理服务器缓存好了源服务器的数据后，并保存了映射关系，就把数据返回给了客户端 A。

很快，客户端 A 又发送相同请求，代理服务器接收了请求且缓存还没过期，且发现请求头依旧有 Accept-Encoding: gzip，于是缓存命中了数据A，数据A被返回给了客户端A。在缓存未过期的期间，只要任何一个客户端的请求头里有 Accept-Encoding: gzip且请求url，代理服务器返回的数据都是数据A。

不久后，不支持解压功能的客户端B 发送一个没有 Accept-Encoding 字段的请求。代理服务器拿到了数据，缓存没有命中，于是和上面一样，拿到一个新的缓存数据B，得到了一个新的映射关系：`URL + 请求方法 + 无 Accept-Encoding 的头字段 -> 数据B`
如果代理服务器不使用 Vary，纯粹只是根据 请求URL和请求方法 来判断是否缓存命中，那不支持解压功能的 客户端B 就可能会错误拿到代理服务器中的被压缩过的 数据A。

通过 Vary 头字段，我们可以避免客户端B拿到一个无法解压的数据A。

总结：vary 头字段的作用-让代理服务器的缓存命中更多的决定因子，而不仅仅是依据请求URL和请求方法来决定是否命中。



## 把样式表放在顶部

把样式表放在顶部可以避免 白屏 和 无样式内容的闪烁

注意不要使用 @import 引入样式表

问题一： 浏览器渲染流程

1. 浏览器通过HTTP协议请求服务器，获取**HTML文档**并开始从上到下解析，构建DOM
2. 在构建DOM过程中，如果遇到外联的样式表声明和脚本声明,则暂停**HTML文档**解析,创建新的网络连接,并开始下载样式文件和脚本文件
3. 样式文件下载后,构建CSSDOM;脚本文件下载完成后,解释并执行,然后继续解析**HTML文档**构建DOM
4. 完成**HTML文档**解析后,将DOM和CSSDOM进行关联和映射,最后将视图渲染到浏览器窗口.

问题二：@import 和 link 的区别



## 把脚本放在底部

浏览器可以并行地执行HTTP请求

HTTP 1.1 规范建议浏览器从每个主机名并行地下载两个组件。

但是下载脚本时并行下载实际上是被禁用的---即使使用了不同主机名，浏览器也不会启动其他的下载。

正是因为上面的原因，如果脚本放在顶部。那么脚本会阻塞对其后面内容的呈现，会阻塞对其后面组件的下载。

我们可以使用 `defer` 和`async`来控制脚本的执行

1. 如果没有defer 和 async ，浏览器会进行脚本文件的下载和执行,它是和文档解析同步进行的，也就是说会阻塞文档的解析。
2. async 浏览器会异步下载脚本，并在允许的情况下执行，不会按照scripte在页面中的顺序执行，谁先加载完先执行谁。
3. defer 浏览器会异步下载脚本，并且不会影响后续DOM的渲染。会按照script在页面中的顺序执行

[参考](https://www.cnblogs.com/jiasm/p/7683930.html)



## 避免CSS表达式



## 使用外部JavaScripte 和 CSS



## 减少DNS查找

##### 影响DNS缓存的因素

1. DNS 记录存活时间 (TTL)，该值告诉客户端可以对该记录缓存多久。
2. 浏览器对缓存的DNS记录的数量也有限制，而不管缓存记录的时间。



##### 减少DNS查找

方法一： 较少的域名

当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等，包括页面URL、图片、脚本文件、样式表、Flash对象等的主机名。减少唯一主机名的数量可以减少DNS查找的数量。

但是减少唯一主机名的数量会潜在地减少页面中并行下载的数量，所以要做好权衡

方法二：使用keep-alive 

通过重用现有连接，从而通过避免TCP/IP开销来减少响应时间



## 避免重定向

**重定向**用于将用户从一个URL重新路由到另一个URL。有很多种常用的是301和302

重定向的方法：

1. 服务器返回301 302，浏览器会自动将用户带到 Location 字段所给出的URL.。

2. HTML文档的头中包含的 meta refresh 标签可以在其 content 属性所指定的秒数之后重定向用户

   `<meta http-equiv="refresh" content="0;url=http://stevesouders.com/newuri"`

3. JavaScript 可以用于执行重定向，将 `document.location`设置为期望的 URL 即可



引发重定向：

1. 缺少结尾的斜线，会导致301

2. 连接网站，将旧网站连接到新网站，将一个网站的不同部分连接起来，基于一些条件(浏览器类型，用户账户类型等)来引导用户

3. 跟踪内部流量

   重定向经常用于跟踪用户流量的流向。

   也可以选择 Referer 日志来跟踪流量去向。所以可以用referer来避免重定向

4. 美化URL



## 移除重复脚本



## 配置ETag

ETag 会产生性能问题，在不同的服务器上相同的文件 ETag 不同，会导致再次返回200而不是304



## 使Ajax可缓存

'Ajax' 表示异步的JavaScript 和 XML。

Ajax 不是一个单独的、需要许可证的技术，而是一组技术，包括JavaScripte、CSS、DOM和异步数据获取。

Ajax 在UI 和 Web 服务器之间插入了一层，整个Ajax层位于客户端，与Web服务器进行交互以获取请求信息，并于表现层交互，仅更新那些必要的组件。













