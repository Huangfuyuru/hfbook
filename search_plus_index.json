{"./":{"url":"./","title":"简介","keywords":"","body":"hfbook 今天是七月十九号(星期五),纠结了很长时间还是选择了就业，没有考研。 现在已经实习一个半月,团队里的前辈都很厉害，让我很崇拜，希望自己几年以后也可以像他们一样。 不知道转正几率大不大,秋招是应届生的福利,还是要好好准备一下。 打算利用晚上和早上的时间整理秋招的知识点,同时完善一下自己的知识体系。 时间挺紧的,不能面面俱到,尽量复习到。 希望可以在九月初投出自己的简历,得到自己满意的offer!给自己的奖励是——毕业旅行-乐山。 自11月9号收到快手的邮件后，我的秋招结束了！ 知道自己有很多不足的地方，在工作中多查漏补缺！ 好好实习，好好工作，好好锻炼！ 对人真诚，对事认真！ master! dev! 51eb8fc... dev dev-rebase! master-rebase! 87e5082... show powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/javascript/":{"url":"chapters/javascript/","title":"JavaScript","keywords":"","body":"JavaScript 方面 记录 JavaScript 方面的基础知识 这个真的是太重要了！ powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/javascript/ch01.html":{"url":"chapters/javascript/ch01.html","title":"数据类型","keywords":"","body":"JS-数据类型 数据分类 基本数据类型: string , boolean , number ,undefined , null ,symbol 引用数据类型：object , function , date , regexp , array 基本数据类型特点 基本数据类型不可以添加属性和方法 基本数据类型的赋值是简单的赋值 基本数据类型的比较是值的比较 基本数量类型的值被保存在栈中 基本数据类型的值是不变的，任何方法都无法改变一个基本数据类型的值 基本数据类型是按值访问，可以操作保存在变量中的实际的值 引用数据类型特点 引用数据类型的复制是复制一个指针，这个指针指向存储在堆中的对象的地址 引用数据类型的变量保存在栈中，真正的对象保存在堆中。栈中保存的是堆的地址 引用数据类型是按值传递的 Object 的每个实例中都具有下列属性和方法 constructor: 保存着用于创建当前对象的函数 hasOwnProperty(propertyName): 用于检查给定的属性是在当前的对象实例中，而不是在实例的原型中。 isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型 toString(): 返回对象的字符串表示 valueOf(): 返回对象的字符串、数值或布尔值表示 判断数据类型 typeof typeof 可以判断基本数据类型和函数 ，但是 null 和 object 类型都会返回 object instanceof instanceof 来判断变量是引用类型的实例 colors instanceof Array 返回 true 类型转换 boolean值 falsy 值(虚值) 是在boolean上下文中认定为false的值 false 0 '' \"\" `` 注意 “ ”是真值 null undefined NaN truthy 值(真值) 是在boolean上下文中认定为true的值 true {} [] 12 \"foo\" \" \" new Date() new Number() Infinity() -Infinity() powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/javascript/原型和原型链.html":{"url":"chapters/javascript/原型和原型链.html","title":"原型和原型链","keywords":"","body":"原型和原型链 什么是原型？ 我们创建的每个函数都有一个prototype属性，这个属性指向一个对象A，就是我们所说的原型对象。对象A上的属性和方法可以由被当前函数生成的实例所共享，对象A会有一个constructor属性，该属性指向对象A所在的函数。由构造函数生成的实例，每个实例都有一个__proto__属性，这个属性也指向对象A这个原型对象。 什么是原型链？ 每个构造函数都有一个原型对象，每个实例都包含一个指向原型对象的指针。那么，我们假如让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针。子类型就能访问超类型的所有属性和方法 简单来说：将一个类型的实例赋值给另一个构造函数的原型 搜索首先从对象实例本身开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索实例的原型对象，在原型对象中查找具有给定名字的属性。 如何实现继承？ 继承原型上的方法和属性，继承实例上属性 方法一：组合继承 将原型链和借用构造函数的技术组合。使用原型链实现对原型属性和方法的继承，借用构造函数来实现对实例属性的继承。 即通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。 function SuperType(name){ this.name = name; this.colors = ['red','pink'] } SuperType.prototype.sayName = function(){ console.log(this.name) } function SubType(name,age){ SuperType.call(this,name); this.age=age; } SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; 方法二：寄生组合继承 组合继承很常用，但是无论在什么情况下，都会调用两次父类构造函数，一次是在创建子类型原型时，一次是在子类型构造函数内部。也就是说子类型最终会包含父类型的全部实例属性 寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路：不必为了指定子类型的原型而调用父类型的构造函数，我们所需的无非就是父类型原型的一个副本而已。 function SuperType(name){ this.name = name; this.colors = ['red','blue','green'] } SuperType.prototype.sayName = function(){ console.log(this.name) } function SubType(name,age){ SuperType.call(this,name); this.age = age } inheritPrototype(subType,SuperType); SubType.prototype.sayAge = function(){ console.log(this.age) } function inheritPrototype(subType,superType){ var prototype = Object.create(superType.protoype); prototype.constructor = subType; subType.prototype = prototype; } 如何确定实例和原型的关系？ instanceof 操作符 ins 这个实例有自己的原型链，如果 SubType 在他的原型链中返回 true ins instanceof SubType isPrototypeOf() 只要在ins 的原型链中出现过的原型，返回true SubType.prototype.isPrototypeOf(ins) 如何确定属性在实例中还是在原型中？ hasOwnProperty() 方法 可以检测一个属性是否存在于实例中。 ins.hasOwnPropertyOf(\"name\") in 操作符 + Object.keys() in 判断该属性是否在对象中，但是无法确定是在实例中还是原型中 取得对象上所有可枚举的实例属性,Object.keys() 这个方法接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 取得对象上所有实例属性，使用Object.getOwnPropertyNames() new操作符 创建一个新对象 将构造函数的作用域赋给新对象(因此this就指向了这个新对象) 执行构造函数中的代码(为这个新对象添加属性) 返回新对象 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/javascript/作用域.html":{"url":"chapters/javascript/作用域.html","title":"作用域","keywords":"","body":"作用域 先说执行环境，每个函数都有自己的执行环境，全局执行环境是最外围的一个执行环境。在执行环境中可以定义变量和函数，这些变量和函数被保存在一个变量对象中，也就是说在执行环境中定义的变量和对象会成为这个变量对象的属性，但是我们无法访问这个对象，解析器会在处理数据时使用它。 当执行流进入一个函数时，函数的环境就会被推入到一个环境栈中，在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链，我们可以理解成原型链。作用域链保证了对执行环境中有权访问的所有变量和函数的有序访问。作用域链的前端是当前执行的代码所在环境的变量对象，如果这个环境是函数环境，则将其活动对象作为变量对象。活动对象在最开始只包含一个变量arguments,也可能包含this。作用域链的下一个对象来自包含环境，再下一个对象来自下一个包含环境，这样一直延续到全局执行环境。 var color = \"blue\" function changeColor(){ var anotherColor = 'red'; function swapColors(){ var tempColor = anotherColor; anotherColor = color; color = tempColor } swapColors(); } 有三个执行环境：全局环境、changeColor()的局部环境、swapColors()环境 全局环境对象中有一个变量color和一个函数changeColor() changeColor环境对象中有一个变量anotherColor和一个函数swapColors() swapColors环境对象中有一个变量tempColor 所以swapColors 对象的原型链是 swapColors->changeColor->全局 changeColor对象的原型链是 changeColor->全局 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/javascript/闭包.html":{"url":"chapters/javascript/闭包.html","title":"闭包","keywords":"","body":"闭包 含义：指有权访问另一个函数作用域中的变量的函数。 创建闭包的常见方式：在函数A内部创建函数B，将B抛出 因为B是在函数A中创建，所以B的作用域链中包含A的执行环境对象。也就是说B可以使用在A执行环境中定义的函数和变量。当A执行完毕后，不会被销毁，因为B的原型链中还使用A 再次读闭包章节又有了新的收获！！！~ function createFunctions(){ var result = new Array(); for(var i=0;i 返回的result 数组每个函数执行都会打印10.为什么？ 作用域链的这种配置机制有一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。result[i]函数中保存createFunctions的活动对象，这个对象是相同的，这个对象中的属性i是在变化的，所以每个函数内部i的值都是10. 解决方法，创建闭包 function createFunctions(){ var result = new Array(); for(let i=0;i 我们创建了一个立即执行函数，将立即执行的结果赋值给了result[i]。 立即执行函数执行是，会把i传入给sum。而里面的匿名函数因为作用域链保存的是sum的值。 this对象 this 对象是在运行时基于函数的执行环境绑定的:在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。 var name = \"The window\" var object = { name:'My object', getNameFunc:function(){ return function(){ return this.name } } } console.log(object.getNameFunc()())//'The window' 返回的是'The window'而不是'My object' 因为每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不会直接访问外部函数中的这两个变量，但是，把外部作用域中的this对象保存在一个闭包可以方法的变量中，闭包就能访问该对象了。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/es6/":{"url":"chapters/es6/","title":"ES6","keywords":"","body":"ES6 方面 记录 ES6 方面 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/es6/promise.html":{"url":"chapters/es6/promise.html","title":"Promise","keywords":"","body":"Promise 对象 Promise 含义 Promise 是一个容器，里面保存着某个未来才会结束的事情的结果。 从语法上说，Promise是一个对象，从它可以获取异步操作的消息。 Promise 对象有下面两个特点 (1) 对象的状态不受外界影响。pending、fulfilled、rejected三种状态。只有异步操作的结果，可以决定当前是哪一种状态。 (2) 一旦状态改变，就不会在变。 基本用法 Promise对象是一个构造函数，用来生成Promise实例。 Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。 Promise实例生成以后，可以使用then方法分别指定resolved和rejected状态的回调函数。 then方法可以接受两个回调函数作为参数，第一个回调函数是Promise对象的 状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用，第二个函数可选。 Promise.prototype.then() Promise 实例具有then方法。也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。 then方法返回的是一个新的Promise实例(不是原来那个Promise实例)。因此可以采用链式写法。then方法后面再调用另一个then方法。 Promise.prototype.finally() finally() 不管Promise对象最后状态如何，都会执行的操作 。 Promise.all() Promise.all() 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例 const p = Promise.all([p1,p2,p3]) Promise.all()方法接受一个数组作为参数，p1,p2,p3是Promise实例。如果不是，会先调用Promise.resolve方法，将参数转为Promise实例。 p的状态由p1,p2,p3决定 (1) 当p1,p2,p3状态都变为resolved，p的状态才会变成resolved，此时p1,p2,p3的返回值组成一个数组，传递给p的回调函数。注意，如果p1,p2,p3中有的状态变为reject但是使用catch进行捕捉并返回,p 拿到的状态是resloved (2) 只要p1,p2,p3之中有一个被rejected，p的状态就变成rejected,此时第一个被rejected的实例的返回值，会传递给p的回调函数。 Promise.race() Promise.race() 方法也是将多个Promise实例，包装成一个新的Promise实例 const p = Promise.race([p1,p2,p3]) 但是与all() 方法不同的是，只要p1,p2,p3之中有一个实例率先改变状态，p的状态就跟着改变。 Promise.allSettled() Promise.allSettled()方法接受一组Promise实例作为参数，包装成一个新Promise实例。只有等到所有这些参数实例都返回结果，不管是resolved还是rejected，包装实例才会有结果 Promise.any() Promise.any() 方法接受一组Promise实例作为参数，包装成一个新的Promise实例。只要参数实例中有一个是resolved状态，包装实例就会变成resolved状态。如果所有参数实例都变成了rejected状态，包装实例就会变成rejected状态。 Promise.resolve() 将现有对象转为Promise对象 (1) 参数是一个Promise实例 (2) 参数是一个thenable对象 (3) 参数不是具有then方法的对象，或根本 就不是对象 (4) 不带有任何参数 Promise.reject() 应用 加载图片 function loadImg(url){ return new Promise((resolve,reject)=>{ let image = new Image(); image.src = url; image.onload = function(){ resolve(image) } image.onerror = function(){ reject(image) } }) } loadImg('./a.jpg').then((res)=>{ document.body.appendChild(res) }).catch((res)=>{ console.log('出错了',res) }) console.log('start'); setTimeout(()=>{ console.log('time') }) Promise.resolve().then(()=>{ console.log('resolve') }) console.log('end') //start //end //resolve //time 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出start和end。 setTimout作为一个宏任务被放入宏任务队列(下一个) Promise.then作为一个微任务被放入微任务队列 本次宏任务执行完，检查微任务，发现Promise.then，执行它 接下来进入下一个宏任务，发现setTimeout，执行。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/es6/箭头函数.html":{"url":"chapters/es6/箭头函数.html","title":"箭头函数","keywords":"","body":"箭头函数 注意点： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，不能用new 命令 不可以使用 arguments 对象，该对象在函数体内不存在。如果要使用，可以用rest参数代替 不可以使用 yield 命令,因此箭头函数不能用作 Generator 函数。 不适用场合 定义对象的方法，且该方法内部包括 this const cat = { lives: 9, jumps: ()=>{ this.lives--;//这时候的this指向的是全局变量window } } 需要动态this的时候，也不应使用箭头函数 var button = document.getElementById('press'); button.addEventListener('click',()=>{ this.classList.toggle('on') }) powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/html/":{"url":"chapters/html/","title":"Html","keywords":"","body":"HTML 方面 记录 HTML 方面基础知识 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/html/网页元素位置.html":{"url":"chapters/html/网页元素位置.html","title":"网页元素位置","keywords":"","body":"event.clientX event.clientY 鼠标相对于浏览器窗口可视区域的X、Y坐标，可视区域不包括 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/css/":{"url":"chapters/css/","title":"CSS","keywords":"","body":"css 方面 花里胡哨的页面 炫到爆炸 就靠你了 主要看张鑫旭作者的《CSS 世界》，粗略的看了一遍，有很多不懂的地方。需要再看 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/css/css.html":{"url":"chapters/css/css.html","title":"小知识点","keywords":"","body":"width: auto 和 height: auto width、height的默认值都是auto 对于块级元素，流体布局之下width:auto自适应撑满父元素宽度。这里的撑满并不同于width:100%的固定宽度，而是像水一样能够根据margin不同来自适应父元素的宽度 对于内联元素，width:auto则呈现出包裹性，即由子元素的宽度决定 无论是内联元素还是块级元素，height:auto都是呈现包裹性，即高度由子级元素撑开。 注意：正常流下，如果块级元素的width是个固定值，margin是auto，则margin会撑满剩下的空间，如果margin是固定值，width是auto，则width会撑满剩下的空间 选择器优先级 内联样式 > ID选择器 > [类 | 伪类 | 属性选择器] > [标签 | 伪元素选择器] > [通用选择器 | 子选择器(>) | 相邻选择器(+) | 同胞选择器(~)] 伪元素 : :before / :after 盒模型 下面的这个做法，可以让所有的盒子box-sizing为border-box,太美了，有没有 :root { box-sizing: border-box } * { box-sizing: inherit } padding padding 不可为负值，但是可以为百分比值。为百分比时垂直和水平方向的padding都是相对于父级元素宽度计算的。 margin 作为外边距,margin属性不会参与盒子宽度的计算，但是通过设置margin为负值,却能改变元素的宽度,但这种情况只会在流布局时(也就是width是默认的auto)，如果元素设定了宽度，或者元素设置了float:left/position:absolute这样的属性改变了流布局，那么margin为负无法改变宽度 块级元素的垂直方向会发生margin合并，存在三种场景 相邻兄弟元素之间maring合并 父元素margin-top和子元素margin-top,父元素的margin-bottom和子元素的margin-bottom 空块级元素自身的margin-top和margin-bottom合并 组织maring合并 把元素放到BFC中 设置border或padding阻隔margin 用内联元素阻隔 给父元素设定高度 margin的百分比和padding一样，垂直方向和水平方向的百分比都是相对于父元素宽度计算 css属性简单继承 css分为默认继承和默认不继承，当没有指定值时(也就是说这个元素没有设置这个属性时)，默认继承的属性取父元素的同属性的计算值，默认不继承的属性取属性的初始值(初始值是指当属性没有指定值时的默认值)。 默认继承的属性 所有元素默认继承: visibility 、cursor 文本属性默认继承: letter-spacing 、word-spacing 、white-space 、line-height 、color 、font 、font-family 、font-size 、font-style 、font-weight 、text-align 、text-shadow 、text-transform 、direction 、text-indent 列表元素默认继承: list-style 、list-style-type 、list-style-position 、list-style-image 表格元素默认继承: border-collapse 默认不继承的属性 所有元素默认不继承: all 、display、 overflow、 contain 文本属性默认不继承: vertical-align、text-decoration、text-overflow 盒子属性默认不继承: width、height、padding、margin、border、min-width、min-height、max-width、max-height 背景属性默认不继承: background、background-color、background-image、background-repeat、background-position、background-attachment 定位属性默认不继承: float、clear、position、top、right、bottom、left、z-index、 内容属性默认不继承：content、counter-reset、counter-increment 轮廓属性默认不继承：outline-style、outline-width、outline-color、outline 页面属性默认不继承：size、page-break-before、page-break-after 声音属性默认不继承：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during 所有属性都可以通过设置inherit来实现继承 四个通用属性值 inherit : 开启继承 initial : 重置为默认值 unset : 将属性重置为自然值 revert : 使用样式表中定义的元素属性的默认值。 line-height 和 vertical-align line-height和vertical-align是控制元素垂直对齐的两大属性` 在内联元素的垂直方向对齐中，基线是最为重要的概念。line-height定义的就是两基线之间的距离，vertical-align的默认值就是基线。 line-height line-height属性用于设置多行元素的空间量，如多行文本的间距。 对于块级元素来说，line-height决定行框盒子的最小高度，不是实际高度，当元素设置了高度，line-height不起作用 对于内联元素来说，内联元素的行框盒子的高度完全由line-height决定。 line-height 实现垂直居中 行距是指一行文本和相邻文本之间的距离。行距具有上下等分的机制：文字上下的行距是一样的。 还有很多不懂的地方 链接 float 包裹性：此时元素width会像height一样由子元素决定，而不是默认撑满父元素 BFC：元素设置为float:left之后，其display的计算值就成了block 没有任何margin合并 脱离文档流 定位 绝对定位 absolute 定义 绝对定位是完全的脱离文档流，绝对定位一旦产生就不会对周围元素产生任何影响 默认最大宽度为包含块的宽度 包含块指的是距离最近的position不为static的祖先元素 无依赖绝对定位(不设置top,right等) 如果元素是内联元素，那么当无依赖绝对定位后，则和内联元素在同一行显示。如果元素是块级元素，则换行显示 绝对定位和overflow:hidden 当overflow:hidden元素在绝对定位和包含块之间的时候，绝对定位元素不会被裁剪 流体特性 当绝对定位元素的水平方向(left/right)或垂直方向(top/bottom)的两个定位属性同时存在的时候，绝对元素在该方向上便具有了流体特性。此时的width/height属性具有自动撑满的特性，和一个正常流的div元素的width属性别无二致 固定定位 fixed 相对于屏幕视口的位置来指定元素位置。但是当祖先元素的transform属性为none时，相对定位由视口改为该祖先元素。 粘性定位 sticky #one {position: sticky;top: 10px} 在视口滚到到元素top距离小于10px之前，元素为相对定位。之后，元素将固定在与顶部距离10px的位置。直到视口回滚到阈值以下。 元素的显示与隐藏 display:none元素不可见、不占据空间、资源会加载、DOM可访问 visibility:hidden元素不可见、不能点击、但占据空间、资源会加载 opacity:0元素不可见、可以点击、占据空间 opacity:0;position:absolute元素不可见、可以点击、不占据空间 position:relative;z-index:-1元素不可见、不能点击、占据空间、可以使用 position:absolute;z-index:-1元素不可见、不能点击、不占据空间，可以使用 display:none 与 visibility:hidden区别 display:none的元素不会占据任何空间，visibility:hidden的元素会占据空间 display:none会影响css3的transition过渡效果，visibility:hidden不会 display:none隐藏产生重绘和回流,visibility:hidden只会触发重绘 株连性:display:none的节点和子孙节点全都不见。visibility:hidden的节点的子孙节点元素可以设置visibility:visile显示。但是要注意visibility:hidden属性具有继承性，所以子孙元素默认继承了hidden而隐藏，但是当子孙元素重置为visibility:visible就不会被隐藏 css 的两种盒模型 有两种：IE 盒子模型、W3C盒子模型 盒模型：内容、填充、边框、边界 区别：W3C盒子的width 指的是内容部分的宽度，IE的content部分把padding 和 border 计算了进去，所以他的width指的是content+padding+border 水平 没总结 垂直居中 行内元素和块级元素区别 css 如何处理类名冲突问题 首屏时间 图片懒加载 预加载 BFC 弹性布局 层叠规则 流：CSS中一种基本的定位和布局机制。 流体布局：利用元素“流”的特性实现的各类布局效果。 CSS3 的新特性： 一、布局更为丰富 • 移动端的崛起，催生了 CSS3 媒介查询以及许多响应式布局特性的出现，如图片元素 的 srcset 属性、 CSS 的 object-fit 属性。 • 弹性盒子布局（flexible box layout）终于熬出了头。 • 格栅布局（grid layout）姗姗来迟。 二、 视觉表现长足进步。 • 圆角、阴影和渐变让元素更有质感。 • transform 变换让元素有更多可能。 • filter 滤镜和混合模式让 Web 轻松变成在线的 Photoshop； • animation 让动画变得非常简单。 伪类选择器： 伪元素选择器：： 关系选择器 空格 后代选择器 大于号\">\" 相邻后代选择器 ~ 兄弟选择器 \"+\" 相邻兄弟选择器 每个元素都有两个盒子，外在盒子和容器盒子 外在盒子负责元素是可以一行显示，还是只能换行显示 内在（容器）盒子负责宽高、内容呈现 display:block由外在的“块级盒子”和内在的“块级容器盒子”组成 display:inline-block由外在的“内联盒子”和内在的“块级容器盒子”组成。所以他即可以和图文显示在一行，又能直接设置width/height widht/height 作用在 内在盒子 你说 inline-block 是块元素还是内联元素，是内联元素 我们设置width是其实设置的是内在盒子的宽度，但是当不设置width，而是让它使用默认值“width:auto”时，内在盒子的宽度就会根据内部尺寸和外部尺寸来决定它的真实宽度。内部尺寸表示尺寸由内部元素决定，外部尺寸表示宽度由外部元素决定。 width:auto 它包含四种特性 充分利用可用空间 fill-available 比如说 这些元素的宽度默认是100%于父级容器的，撑满可用空间 收缩与包裹 fit-content 元素浮动、绝对定位、inline-block、table将元素宽度收缩为内容宽度 收缩到最小 min-content 采用内部元素最小宽度指值最大的那个元素的宽度作为最终容器的宽度 最小宽度值，例如图片的最小宽度值是图片呈现的宽度，文本元素，中文是一个中文的宽度，英文是一个单词的长度 超出容器限制 max-content 表示采用内部元素宽度值最大的那个元素的宽度作为最终容器的宽度。 外部尺寸的表现 特性一，正常流宽度 格式化宽度，position设置为absolute或fixed的元素，它的宽度表现的是内部尺寸，但是当它的right\\left或top\\bottom这种对立方位的属性值同时设置了，这个时候它的宽度表现的是外部尺寸，它的宽度大小相对于最近的具有定位特性的祖先元素计算。 div{position:absolute;left:20px;right:20px},假设该div元素最近的具有定位特性的祖先元素的宽度是1000像素，则这个div元素的宽度是960像素 内部尺寸的表现 如何判断一个元素使用的是内部尺寸内，假如这个元素里面没有内容，宽度是0，那他应用的是“内部尺寸”。如果这个元素中没有内容，但是它的宽度不为0，那它应用的是“外部尺寸” .parent{ width: 300px; height: 200px; background:pink } 内层的div，它的尺寸是300*0 内层的span，它的尺寸是0*0，说明span应用是内部尺寸 内部尺寸的表现： 收缩与包裹 fit-content 包裹和自适应，自适应指元素尺寸由内部元素决定，但永远小于“包含块”容器的尺寸。 所以一个元素display设为inline-block,那么里面的内容即使再多，只要是正常文本，宽度也不会超过容器。 .parent-btn{ width: 100px; } 按钮按钮按钮按钮按钮按钮按钮按钮按钮按钮 button 这个 html元素是 display 是 inline-block,当button的父元素 width 设为 100px,button的宽度由内部尺寸决定，也就是内部元素的尺寸决定，当“按钮”两个字很多时，也没有改变父元素的宽度。这就体现了自适应，宽度不会超过“包含块”容器的尺寸 这个例子中，当文字少的时候居中，当文字多的时候居左。为什么呢？ .box { text-align:center } .content { display:inline-block; text-align:left; } 因为 content 的display 属性是 inline-block，也就是说它的宽度由内部元素决定，也就是文字内容，而文字内容较少，因为包裹性，所以text-align:left没有发挥左右，而外层box设置了text-align:center,因为content的外在盒子是inline,所以content居中。当文字增多时，content的宽度会变大，因为每一行会有空余，这个时候text-align:left会发挥作用，使文本靠左。但是不会超过“包含块”容器的宽度，所以其实content相对于box它还是居中的 收缩到最小 min-content 采用内部元素最小宽度指值最大的那个元素的宽度作为最终容器的宽度 超出容器限制 max-content 最大宽度就是元素可以有的最大宽度。等同于“包裹性”元素设置white-space:nowrap 声明后的宽度，white-space:nowrap 说明连续的内联元素不会换行。如果内部没有块级元素或者块级元素没有设置宽度值，则“最大元素”实际上是最大的连续内联盒子的宽度。 这个例子,li 设置 inline-block ,说明每个li是一个内联元素，而 ul设置white-space:nowrap,不换行，所以它的wrap的最大宽度就是所有li的宽度 height:100% height和width对百分比单位的支持是不同的。 对于width属性，如果父元素width为auto,百分比值是支持的，但是对于height属性，如果父元素height为auto，只要子元素在文档流中，其百分比值就完全被忽略。例如 div{ width:100%; height:100%; //失效的 background:url(big.jpg) } 这个时候height是失效的，没有高度，我们必须给父元素设置一个具体的高度值。 如何让元素支持 height:100% 设定显式的高度值 使用绝对定位 div { height:40%; position:absolute } 注意，这个时候的height是相对于父元素的padding-box来计算的 max-width/max-height 初始值是none. min-width/min-height 初始值是auto max-width会覆盖width img {max-width:256px} 答案是256px, style !important都会失效，因为max-width会覆盖width 超越最大 超越最大指的是 min-width 覆盖max-width,当min-width 和 max-width 发生冲突的时候。 内联元素 内联元素的“内联”指的是“外在盒子”，inline-block和inline-table都是内联元素，也是内联元素，因为其display是inline-block 内联元素的特征就是可以和文字在一行显示。因此，文字是内联元素，图片是内联元素，表单控件也是内联元素。 幽灵空白节点：在H5文档声明中，在每个“行框盒子”前面，具有该元素的字体和行高属性的0宽度的内联盒。 每一行就是一个行框盒子。 替换元素 替换元素：通过修改某个属性值呈现的内容就可以被替换的元素称为“替换元素” 都是典型的替换元素。替换元素除了内容可替换外，还有以下一些特性 (1) 内容的外观不受页面上的 css 的影响。注意是内容的外观 (2)有自己的尺寸 (3)在很多CSS属性上有自己的一套表现规则。 所有替换元素都是内联元素 替换元素的尺寸计算规则 (1)固有尺寸：指替换内容原本的尺寸。 (2)HTML尺寸：HTML尺寸只能通过HTML原生属性改变,这些 HTML 原生属性包括的 width 和 height 属性、 的 size 属性、 的 cols 和 rows 属性等 (3)CSS尺寸:特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸。 计算规则:CSS 尺寸>HTML 尺寸 > 固有尺寸 如果固有尺寸含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依照固有的宽高比例显示。所以我们一般设置宽度而不设置高度，就是利用这个特性 img {width:200px} 最终图片所呈现的宽高是 200 * 150 padding padding 属性是不支持负值的 padding 支持百分比值，padding 百分比值无论是水平方向还是垂直方向均相对于宽度计算 基线 内联元素默认是基线对齐，字母x的下边缘就是基线，所以内联元素默认和字母x的下边缘对齐。vertical-align 控制内联元素的基线位置。 浮动 块状化的意思是，元素一旦float的属性值不为none,则其display计算值就是block或者table 为什么float 会让父元素的高度塌陷? vertical-align vertical-align 只会对内敛元素起作用 目标元素自己的基线都默认和字母x的下边缘对齐 比如 vertical-align:middle 是将自己的基线变为中间，然后和x的下边缘对齐。 比如一个图片的默认基线是图片的下边缘，那么他的默认显示是图片下边缘和x的下边缘对齐，当给图片设置了vertical-align:middle，那么该图片的基线就变为图片的中心线然后和x的下边缘对齐。 x的大小可以通过line-height来设置。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/css/flex.html":{"url":"chapters/css/flex.html","title":"flex","keywords":"","body":"FlexBox(弹性盒子) 设置了display:flex的元素称为Flex容器(flex container)，容器的子元素称为Flex项目(flex items). container默认存在两根轴：主轴和垂直的交叉轴 FlexBox Container属性 1.flex-direction 定义主轴的方向，也就是\"items\"的排列方向 row:主轴为水平方向，从左边开始排列 row-reverse:主轴为水平方向，从右边开始排列 column:主轴为垂直方向，从上往下排列 column:主轴为垂直方向，从下往上排列 2.flex-wrap 一行排不开时，是否换行，如果换行，按照什么方向 nowrap(默认)：不换行，如果排满了，就缩小\"items\"的尺寸 wrap:换行，沿交叉轴的方向 wrap-reverse:换行，沿交叉轴的相反方向 3.flex-flow flex-flow是flex-direction和flex-wrap的简写 flex-flow:row nowrap 4.justify-content \"items\"在主轴上的对齐方式 flex-start(默认值):左对齐 flex-end:右对齐 center:中间 space-between:两端对齐，“items”之间 的间隔相等 space-around:每个项目两侧的间隔相等 5.align-items \"items\"在交叉轴上的对齐方式 flex-start:在交叉轴的起点对齐 flex-end:在交叉轴的终点对齐 center:在交叉轴的中点对齐 baseline:与\"items\"的第一行文字的基线对齐 stretch(默认值):如果项目未设置高度或设为auto,将占满整个容器 6.align-content align-content定义了多根轴线的对齐方式，当\"items\"不止一行。如果项目只有一行，该属性不起作用 flex-start:与交叉轴的起点对齐 flex-end:与交叉轴的终点对齐 center:与交叉轴的中点对齐 space-between:与交叉轴的两端对齐，主轴方向\"items\"没根轴之间间隔平均 space-around:每根主轴方向\"items\"两侧的间隔都相等 stretch:（默认值）每根\"items\"轴线展开占满整个交叉轴 Flexbox items属性 1.order 定义单个\"item\"的排列位置，属性值值越小，排列越靠前，默认为0 .item{ order:2 } 2.flex-grow 定义“item”的放大比例，默认为0，也就是如果存在剩余空间，也不放大。如果每个\"item\"的flex-grow属性值为1，那么每个\"item\"等分剩余空间 3.flex-shrink 定义\"item\"的缩小比例，默认为1，如果空间不足，该\"item\"将等比例缩小。设置为0时，当空间不足时,item不缩小。设置为2时，缩小比例默认为2倍 4.flex-basis flex-basis属性定义了在分配多余空间之前，“item” 占据的主轴空间。浏览器可以根据这个属性，计算主轴是否还剩余空间。默认值为`auto``，即 “item” 的本来大小。 它可以设为跟width或height属性一样的值，则 “item” 将占据固定空间。 5.flex 是flex-grow,flex-shrink,flex-basix的简写属性，默认值为0 1 auto 改属性有两个简写值： flex: auto; 等同于 flex: 1 1 auto;。 flex: none; 等同于 flex: 0 0 auto;。 flex:1;等同于flex:1 1 0%; flex:2;等同于flex:2 2 0%; 6.align-self align-self属性允许单个 “item” 可以和其他项目有不一样的对齐方式。 可覆盖align-items属性。默认值为auto，表示继承 “container” 的align-items属性。 相关资料1 相关资料2 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/css/布局.html":{"url":"chapters/css/布局.html","title":"布局","keywords":"","body":"垂直水平居中 //css .parent{ width:800px; height: 800px; background:black; position: relative; } .son{ height: 400px; width: 600px; background:hotpink; position: absolute; top:50%; left:50%; margin-top: -200px; margin-left: -300px; } //html //css .parent{ width:800px; height: 800px; background:black; position: relative; } .son{ height: 400px; width: 600px; background:hotpink; position: absolute; top:50%; left:50%; transform: translate(-50%,-50%); } //html 三栏布局 左中定宽，右边自适应 *{ margin:0; padding:0 } .left{ width: 200px; height: 300px; background: skyblue; float: left; } .middle{ width: 300px; height: 300px; background: slateblue; float: left; } .right{ height: 300px; background:peru; } //html 左列定宽 中间定宽 右列自适应 .left{ width: 200px; background: skyblue; } .middle{ width: 300px; background: slateblue; } .right{ background:peru; flex:1 } .parent{ display: flex; height: 300px; } 左列定宽 中间定宽 右列自适应 中间自适应，两列定宽 .left{ width: 200px; background: skyblue; } .middle{ flex:1; background: slateblue; } .right{ background:peru; width:200px } .parent{ display: flex; height: 300px; } 左列定宽 中间定宽 右列自适应 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/css/animation.html":{"url":"chapters/css/animation.html","title":"动画","keywords":"","body":"animation-duration:指定动画需要多少s完成 animation-delay：设置延时，元素从加载完成到开始执行的间隔 animation-direction：设置动画在每次运动后是反向运行还是重新回到开始位置重复运行 ​ normal:默认值，每个动画循环结束，动画重置到起点重新开始 ​ alternate:动画交替反向运行 ​ reverse:反向运行动画 ​ alternate-reverse:反向交替，反向开始交替 animation-iteration-count:运行次数 animation-name：指定关键帧名称 animation-play-state:允许暂停和恢复动画 ​ running ​ paused animation-timing-function:设置动画速度。即通过建立加速度曲线，设置动画在关键帧之间是如何变化。 ​ linear:动画从头到尾速度相同 ​ ease:默认。动画以低速开始，然后加快，在结束前变慢 ​ ease-in:动画以低速开始 ​ ease-out:动画以高速结束 ​ ease-in-out:动画以低速开始和结束 ​ cubic-bezier(n,n,n,n):在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 animation-fill-mode:指定动画执行前后如何为目标元素应用样式。 animation:name duration timing-function delay iteration-count direction fill-mode play-state powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/computer-network/":{"url":"chapters/computer-network/","title":"网络原理","keywords":"","body":"计算机网络 方面 记录 计算机网络 方面的基础知识 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/computer-network/ch01.html":{"url":"chapters/computer-network/ch01.html","title":"http和https","keywords":"","body":"http/1.x http/2.0 https http/1.x 和 http/2.0 http/1.0 缺点 http/1.0一条连接上只能发送一个请求。http/1.1解决部分并发请求 请求只能从客户端开始。 请求/响应首部没有压缩。并且每次发送的首部中有很多相同的内容 可任意选择数据压缩格式。非强制压缩 http 2.0 改进 多路复用：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成。 压缩 HTTP 首部：压缩 HTTP 请求和响应首部 客户端拉曳 服务器推送：服务器端可以主动提示客户端请求所需的资源。服务器主动向客户端推送数据的功能。 对请求划分优先级 http 和 https 概览 http 在安全方面的缺点： 通信使用明文，内容可能被监听 不验证对方的身份，因此有可能遭遇伪装 无法验证报文的完整性，所以 有可能已遭篡改。 https 是为了解决上面的问题 ​ http + 加密 + 认证 + 完整性保护 = https http 并非是应用层的一种新协议，只是 http 通信接口 部分用 SSL 和 TLS 协议代替而已。 通常，HTTP直接和TCP通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信。 具体解决办法 解决内容可能被监听的问题 --- 加密 方法一 : 对称加密 加密和解密同用一个密钥，不同客户端密钥不同 方法二：非对称加密 客户端共享公钥，服务器掌握私钥。客户端使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。 方法三：对称+非对称加密(https 采用这种方式) 在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。发送密文利用伪随机数生成一个“对称密钥”，然后使用对方的公钥进行加密处理“对称密钥”，对方用自己的私钥解密拿到“对称密钥” 解决报文可能遭篡改问题 --- 数字签名 作用 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名 数字签名能确定消息的完整性，证明数据是否未被篡改过 过程 将文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。 解决通信方身份可能被伪装 --- 数字证书 具体通信过程 1.Client发起一个HTTPS（比如https://juejin.im/user/5a9a9cdcf265da238b7d771c）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。 2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。 3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。 4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。 6.Server使用对称密钥加密“明文内容A”，发送给Client。 7.Client使用对称密钥解密响应的密文，得到“明文内容A”。 8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/computer-network/tcp.html":{"url":"chapters/computer-network/tcp.html","title":"tcp(没有看完)","keywords":"","body":"TCP 三次握手 所有TCP连接一开始都要经过三次握手。客户端与服务器在交换应用数据之前，必须就起始分组序列号，以及其他一些连接相关的细节达成一致。出于安全考虑，序列号由两端随机数生成。 SYN：客户端选择一个随机序列号，并发送一个SYN分组，其中可能还包括其他TCP标志和选项 SYN ACK：服务器给x加1，并选择自己的一个随机序列号y，追加自己的标志和选项，然后返回响应 ACK：客户端给x和y加1并发送握手期间的最后一个ACK分组。 拥塞预防及控制 流量控制 流量控制是一种预防发送端过多向接收端发送数据的机制。否则，接收端可能因为忙碌、负载重或缓冲区既定而无法处理。为实现流量控制，TCP连接的每一方都要通告自己的接收窗口(rwnd)，rwnd保存数据的缓存区空间大小信息。 慢启动 发送端和接收端在建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还要根据网络中不断变化的条件动态改变速度。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/brower/":{"url":"chapters/brower/","title":"浏览器原理","keywords":"","body":"浏览器 方面 主要是和你打交道,得了解了解你 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/brower/ch01.html":{"url":"chapters/brower/ch01.html","title":"浏览器数据存储方式","keywords":"","body":"浏览器数据存储方式 cookie 突然想起为什么yl欧巴让我配置 test.yyuap.com 来替代 localhost 是因为所有项目需要 access_token 实现登录才能访问项目。而access_token 的 domain 配置 yyuap.com，也就是说在二级域名相同的情况下才可以共享 access_token 。 cookie 作用 由于HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。 cookie 属性 expires /max-age: cookie 有效期，省略时默认临时会话 path：cookie 影响的路径，匹配到这个路径才发送这个cookie domain：cookie 是同源限制策略，这个是当前cookie 生效的域名 size：保存当前值的大小 httpOnly：当设为 true 时 ，表示浏览器不能通过 document.cookie更改 cookie 的值。可以避免 xss 攻击更改 cookie 的值 secure：当设为 true 时，cookie 在http 中无效，在 https 中才有效 sameSite：规定浏览器不能在跨域请求中携带 cookies ，减少 CSRF 攻击 cookie 缺陷 存储大小 4kb 左右 同一个域名下的所有请求，都会带上cookie。造成性能浪费 localStorage 存储的数据保存在内存中，不会过期，除非主动清除 大小 5M 左右 只用在客户端，不和服务端通信 以键值对存储，键值对是字符串 数据可以在不同的tab之间共享，但是sessionStorage不可以 特性 cookie localStorage sessionStorage 数据的生命周期 一般由服务器生成，可设置失效时间。如果在浏览器端生成cookie,默认是浏览器关闭后失效 除非被清除，否则永久有效 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4k 5M 5M 与服务器端通信 每次都会携带在HTTP头中 仅在浏览器端保存，不参与和服务器的通信 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/brower/ch02.html":{"url":"chapters/brower/ch02.html","title":"浏览器缓存机制","keywords":"","body":"浏览器缓存机制：强缓存和协商缓存 当我们刷新页面后，一些资源不是从服务器拿取，而是显示memory cache ,disk cache memory cache 是内存中的缓存，主要包含当前页面中已经下载的资源，比如样式、脚本、图片等。读取速度快，但是关闭页面后，内存中的缓存就被释放了 disk cache 是磁盘中的缓存，读取速度要慢一点，但是所有资源文件都可以存在磁盘中。会根据 http header 中的字段判断哪些资源需要缓存，哪些资源已经过期要重新请求。一般，大的文件和使用频率较高的文件会优先放到磁盘。 强缓存 强缓存是不会向服务器发送请求，直接从缓存中读取资源。是通过Expires 和 Cache-Control来实现的。 expires 响应头通过 expires 告诉浏览器在过期时间内直接可以从缓存中读取数据。但是如果修改了本地时间，可能造成缓存失效。 cache-control 当同时拥有expires和cache-control，cache-control优先。 Cache-Control：max-age =300 在这个请求的五分钟之内再次加载该资源时，可以直接从缓存中读取 Cache-Control:public 该资源可以在任何地方被缓存 Cache-Control:private 该资源只可以被浏览器缓存 Cache-Control:no-store 浏览器每次都要从服务器拿资源，真正的数据不缓存在本地 Cache-Control:no-cache 要使用的缓存文件每次都要和服务器确认是最新的文件才能使用 Cache-Control:s-maxage = 60 覆盖max-age ，作用一样，只在代理服务器中生效 Cache-Control:must-revalidate 表示只有校验缓存里是最新文件才能用缓存里的版本 Cache-Control:max-stale=30 能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值） Cache-Control:max-fresh=30 能够容忍的最小新鲜度，min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应 协商缓存 是指强缓存的资源失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存。 缓存有效，返回304和Not Modified。浏览器从缓存中读取资源 缓存失效，返回200和请求结果。 协商缓存利用 [Last-Modified,If-Modified-Since] [ETag,If-None-Match] 这两对header管理。 Last-Modified,If-Modified-Since 浏览器第一次访问该资源时，服务器会在响应头中加入Last-Modified的值，表示这个资源在服务器的最后修改时间。浏览器在下一次请求该资源时，检测到有Last-Modified字段时，就会在请求头加入If-Modified-Since,服务器会根据If-Modified-Since和服务器上的这个资源的最后修改资源进行对比。 弊端：如果本地打开缓存文件，即使没有修改，还是会导致Last-Modified被修改。Last-Modified只能以秒计时，如果快速修改，那么服务器上的资源被修改了，但是Last-Modified不变 ETag,If-None-Match 返回当前资源文件的唯一标识（由服务器生成） ETag 优先级高 总结 强缓存优先协商缓存，若强缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存([Last-Modified/If-Modified-Since],[ETag/If-None-Match])，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中，生效则返回304，继续使用缓存。 用户行为对浏览器缓存的影响 指用户在浏览器如何操作时，会触发怎样的缓存策略 打开网页，输入地址，查找disk cache中是否匹配，如有则使用，没有发送网络请求 普通刷新，由于网页没有关闭，因此memory cache可用，会被优先使用，其次时disk cache 强制刷新，浏览器不使用缓存，此时发送的请求头均带有 cache-control:no-cache 服务器返回最新资源 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/brower/浏览器渲染.html":{"url":"chapters/brower/浏览器渲染.html","title":"浏览器渲染过程","keywords":"","body":"浏览器渲染过程 解析HTML生成DOM树 解析CSS生成CSS树 合并DOM树和CSS树生成渲染树(render树) 计算每个节点在页面的位置 将每个节点绘制到屏幕上 构建DOM树 字节数据->字符串->token->node->dom a)浏览器将获得的html字节数据根据编码(UTF-8)将它转化成在字符串 b)将这些字符串按照html规范标准转换成不同的标记token，每个token有自己的独特的含义以及规则集。 c)将token转换为节点对象，这些对象分别定义了他们的属性和规则 d)遍历这些对象，构建DOM 构建CSS规则树 和DOM树类似 构建渲染树 一般来说，渲染树和DOM树是一一对应的，但一些不可见的DOM元素不会插入到渲染树中，比如，display为none的元素。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个节点找到适配的CSS样式规则并应用。 布局 渲染树生成后，还不能渲染到屏幕上，渲染到屏幕上需要得到每个节点的位置信息。由于每个节点都是一个对象，包含宽高、位置、背景色等信息，所以浏览器可以通过这些样式信息来确定每个节点对象在页面上确切位置。一般回流会发生在这里 绘制 一般重绘会发生在这里 浏览器在渲染过程中遇到JS文件如何处理？ JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，所以渲染过程遇到标签时，DOM构建将暂停，直至脚本完成执行，然后在构建DOM。如果JS还操作了CSS，如果这个CSSOM树没有构建完成的话，JS需要等待CSSOM下载并解析完才可以操作CSSOM。所以一般将JS放在文档底部，或者使用defer,async。 defer不阻塞DOM构建，执行会在DOM构建后，aysnc不阻塞DOM构建，解析完会立即执行 css阻塞渲染？ 必须CSSOM完全生成后才开始渲染 优化：把CSS放在head 尽量使用id,class不要过渡嵌套 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/brower/ch03.html":{"url":"chapters/brower/ch03.html","title":"跨域","keywords":"","body":"跨域 浏览器为了保证用户信息安全，防止恶意的网站攻击，实行同源限制策略 协议相同、域名相同、端口相同 如果是非同源，DOM 无法获得，AJAX 请求不能发送，cookie localStorage 无法读取 跨域解决方式 CORS 方式 CORS 思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应是应该成功还是失败 浏览器会向服务器发送一个Preflight请求，这种请求使用OPTIONS方法，发送下列头部。 Origin: 与简单的请求相同 Access-Control-Request-Method:请求自身使用的方法 Access-Control-Request-Headers:（可选）自定义的头部信息 发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通 Access-Control-Allow-Origin: 与请求头中的Origin相同 Access-Control-Allow-Methods:允许的方法， Access-Control-Allow-Headers:允许的头部 Access-Control-Max-Age:应该将这个Preflight请求缓存多长时间 默认情况下，跨域请求不提供凭据(cookie,http认证及客户端SLL证明等)。通过将withCredentials 属性设置为true,可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的HTTP头部来响应 JSONP web 页面上调用js文件时不受跨域影响 json的纯字符数据格式可以简洁的描述复杂数据，并且被js原生支持 所以，web客户端通过与调用脚本相同的方式，来调用跨域服务器上动态生成的js格式文件(一般以json为后缀)。要点是，用户传递一个callback参数给服务器，服务器返回数据时会将callback参数作为函数包裹JSON数据，这样客户端就可以定制自己的函数来自动处理数据了！ ajax和jsonp本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加 websocket WebSocket 在一个单独地持久连接上提供全双工、双向通信。在JS中创建了WebSocket后，会有一个HTTP请求发送到服务器来发起连接，在取得服务器响应后，建立地连接会使用WebSocket协议，只有支持这种协议地专门服务器才能正常工作。 websocket协议不受同源策略的影响，只要服务器端支持，无需配置就支持跨域。 创建 WebSocket ,先实例一个WebSocket对象并传入要连接的URL var socket = new WebSocket(\"ws://www.example.com/server.php\") 实例化了 WebSocket 对象后，浏览器会马上尝试创建连接。有一个表示当前状态的 readyState 属性 0: 正在建立连接 1：已经建立连接 2：正在关闭连接 3：已经关闭连接 WebSocket 打开之后，就可以通过连接发送和接收数据。使用send() 方法并传入任意字符串 socket.send('Hello world') 当服务器向客户端发来消息时，WebSocket对象就会触发 message 事件。返回数据保存在 event.data 属性中 socket.onmessage = function(event){ var data = event.data } 代理跨域 node服务 本地开发用代理 如果在本地的服务localhost:8080想要访问www.njc.com域下的资源，那么由于同源限制策略，会请求失败。我们可以在请求发送前加入中间层，将不同的域名转换成相同的域名。客户端发请求时，不直接到服务器，先到代理的中间层，在将请求发送到服务器。当服务器返回数据的时候，也是先到代理层。 Access-Control-Allow-Credentials:true powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/brower/eventloop.html":{"url":"chapters/brower/eventloop.html","title":"事件循环机制","keywords":"","body":"事件循环机制 JavaScript 单线程，所以同一时间只能做一件事。但有一些操作，比如 Ajax 请求会阻塞后面的代码执行，所以浏览器给我们提供一些 webapi，可以对应的创建一些线程。 所有代码会被方法到 task 这个执行栈中，当遇到一些带有 callback 的 webapi ，比如 setTimeout、I/O 等该函数会被弹出到 webapi 中进行执行 ，等待其执行完毕，将 callback 放入 task queue。 而事件循环机制的任务就是，查看栈和任务队列，当栈空，就把任务队列队头的任务压入栈中，之后这个任务就会被执行。重绘也是，重绘是在任务队列中的，如果栈不空，那么一直无法进行重绘，UI无法很好的呈现 来想一下下面代码的执行过程 let btn = document.getElementById('btn'); console.log('start'); btn.addEventListener('click',function(){ console.log('click') }) setTimeout(function(){ console.log('Timeout') },5000) console.log('Done') 观看了 JSConf 视频总结 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/brower/xss.html":{"url":"chapters/brower/xss.html","title":"XSS和CSRF攻击","keywords":"","body":"xss攻击： 中文是跨站脚本攻击，指的是攻击者在网站恶意注入代码，通过恶意脚本对客户端网页进行篡改，当用户浏览网站时，对用户浏览器进行控制或者获取用户隐私的一种攻击方式。 对客户端网页注入的恶意脚本一般包括JavaScript XSS攻击分为三类：非持久性、持久性、基于DOM 类型 存储区(恶意代码存放的位置) 插入点(由谁取得恶意代码，并插入到网页上) 持久型 XSS 后端数据库 HTML 非持久性 XSS URL HTML DOM 型 XSS 后端数据库/前端存储/URL 前端 JavaScript 非持久性：简单地把用户输入的数据反馈给浏览器。 持久性：把用户输入的数据存储到服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。 基于DOM：通过恶意脚本修改页面的DOM结构，发生在客户端的攻击 XSS攻击的防范： 1.用户的输入检查：对用户的任何输入都要进行检查、过滤和转义，一般时检查等特殊字符，如果存在进行过滤或编码。 2.服务器的输出检查： 3.HttpOnly防止劫取Cookie: CSRF攻击 中文是跨站请求伪造，劫持受信任用户向服务器发送非预期请求的攻击方式。借助受害者的Cookie骗取服务器的信任，在受害者毫不知情的情况下以受害者的名义伪造请求发送给服务器。 cookie策略 cookie用途：会话管理状态，个性化设置，浏览器行为跟踪 cookie种类：会话期cookie ​ 持久性cookie:可以指定特定的过期时间(Expires)或有效期(Max-Age) csrf攻击防范 验证码 验证码会强制用户必须与应用进行交互，才能完成请求 SSL连接 要求以SSL连接来访问 添加token验证 在http请求中以参数的形式随机生成一个token，并在服务器建立一个拦截器来验证token 好好看 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/design-pattern/":{"url":"chapters/design-pattern/","title":"设计模式","keywords":"","body":"设计模式 方面 初次见面,请多关照！ powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/regex/":{"url":"chapters/regex/","title":"正则","keywords":"","body":"正则方面 记录正则表达式方面 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/optimize/":{"url":"chapters/optimize/","title":"性能优化","keywords":"","body":"性能优化 方面 我希望我的网站 别人不会等很长时间 主要看 《高性能网站建设指南》进行总结 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/optimize/ch01.html":{"url":"chapters/optimize/ch01.html","title":"图片懒加载","keywords":"","body":"图片懒加载 原理 标签中的src表示图片的url，当这个属性不为空时，浏览器就会根据这个值发送请求，请求资源。当没有src时，不会请求资源，所以当快滑到这个图片时，我们再来给src赋值。可以先使用一个自己设定的属性data-src来存储图片路径。 具体步骤 判断元素是否在可视区域 方法一 document.documentElement.clientHeight 获取屏幕可视窗口高度 element.offsetTop 获取元素相对于文档顶部的距离 document.documentElement.scrollTop 获取浏览器窗口顶部相对于文档顶部的距离 判断 scrollTop-offsetTop 方法二 getBoundingClientRect 可以获取元素的大小以及位置 item.getBoundingClientRect().top 加载图片 如果在可视区，加载图片 优化 节流 实现代码 //html //js window.onload=checkImgs; //页面加载完成，渲染第一张图片 window.onscroll = throttle(checkImgs); //滚动 //判断 图片是否在可视区 function isInsight(el){ const bound = el.getBoundingClientRect(); const clientHeight = window.innerHeight; return bound.top { if(isInsight(el)){ loadImg(el) } }) } //替换 src function loadImg(el){ if(!el.src){ const source = el.dataset.src; el.src = source } } //节流 function throttle(fn, mustRun = 1000) { let prev = Date.now(); return function(){ let href = this; let arg = arguments; let now = Date.now(); if(now-prev>=mustRun){ console.log('context',href) fn.apply(href,arguments); prev = Date.now(); } } } .container{ width:100% } .img-area{ height:600px; text-align:center } powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/optimize/ch02.html":{"url":"chapters/optimize/ch02.html","title":"《高性能网站建设指南》","keywords":"","body":"减少 HTTP 请求 图片地图 允许在一个图片上关联多个URL.通过html的map标签实现 CSS Sprites 也是 将多个图片足组合成一个图片。通过css的background-position属性将HTML元素放置到背景图片中期望的位置上。 内联图片 通过使用 data:URL 模式可以在Web页面中包含图片但无需任何额外的HTTP请求。 格式 data:[][;base64], 一个红色五角星形状的内敛图片可以定义为 合并脚本和样式表 将一些单独的文件合并到一个文件中，类似CSS sprites可以减少HTTP请求的数量 脚本不要和样式表合并在一起，多个脚本合并成一个脚本，多个样式表合并成一个样式表。 使用内容发布网络 内容发布网络是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。 除了缩短响应时间外，CDN还可以带来其他优势。他们的服务包括备份、扩展存储能力和进行缓存。 我们经常把一些比较频繁请求且容量比较大的文件，并且更新频率不那么高的文件放在CDN 使用缓存 长久的Expires头应E该包含任何不经常变化的组件，包含脚本、样式表和Flash组件。但是HTML文档不应该使用长久的Expires头，因为它包含动态内容，这些内容在每次用户请求时都将被更新。 当我们刷新页面后，一些资源不是从服务器拿取，而是显示memory cache ,disk cache memory cache 是内存中的缓存，主要包含当前页面中已经下载的资源，比如样式、脚本、图片等。读取速度快，但是关闭页面后，内存中的缓存就被释放了 disk cache 是磁盘中的缓存，读取速度要慢一点，但是所有资源文件都可以存在磁盘中。会根据 http header 中的字段判断哪些资源需要缓存，哪些资源已经过期要重新请求。一般，大的文件和使用频率较高的文件会优先放到磁盘。 强缓存 强缓存是不会向服务器发送请求，直接从缓存中读取资源。是通过Expires 和 Cache-Control来实现的。 expires 响应头通过 expires 告诉浏览器在过期时间内直接可以从缓存中读取数据。但是如果修改了本地时间，可能造成缓存失效。 cache-control 当同时拥有expires和cache-control，cache-control优先。 Cache-Control：max-age =300 在这个请求的五分钟之内再次加载该资源时，可以直接从缓存中读取 Cache-Control:public 该资源可以在任何地方被缓存 Cache-Control:private 该资源只可以被浏览器缓存 Cache-Control:no-store 浏览器每次都要从服务器拿资源，真正的数据不缓存在本地 Cache-Control:no-cache 要使用的缓存文件每次都要和服务器确认是最新的文件才能使用 Cache-Control:s-maxage = 60 覆盖max-age ，作用一样，只在代理服务器中生效 Cache-Control:must-revalidate 表示只有校验缓存里是最新文件才能用缓存里的版本 Cache-Control:max-stale=30 能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值） Cache-Control:max-fresh=30 能够容忍的最小新鲜度，min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应 协商缓存 是指强缓存的资源失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存。 缓存有效，返回304和Not Modified。浏览器从缓存中读取资源 缓存失效，返回200和请求结果。 协商缓存利用 [Last-Modified,If-Modified-Since] [ETag,If-None-Match] 这两对header管理。 Last-Modified,If-Modified-Since 浏览器第一次访问该资源时，服务器会在响应头中加入Last-Modified的值，表示这个资源在服务器的最后修改时间。浏览器在下一次请求该资源时，检测到有Last-Modified字段时，就会在请求头加入If-Modified-Since,服务器会根据If-Modified-Since和服务器上的这个资源的最后修改资源进行对比。 弊端：如果本地打开缓存文件，即使没有修改，还是会导致Last-Modified被修改。Last-Modified只能以秒计时，如果快速修改，那么服务器上的资源被修改了，但是Last-Modified不变 ETag,If-None-Match 返回当前资源文件的唯一标识（由服务器生成） ETag 优先级高 总结 强缓存优先协商缓存，若强缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存([Last-Modified/If-Modified-Since],[ETag/If-None-Match])，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中，生效则返回304，继续使用缓存。 用户行为对浏览器缓存的影响 指用户在浏览器如何操作时，会触发怎样的缓存策略 打开网页，输入地址，查找disk cache中是否匹配，如有则使用，没有发送网络请求 普通刷新，由于网页没有关闭，因此memory cache可用，会被优先使用，其次时disk cache 强制刷新，浏览器不使用缓存，此时发送的请求头均带有 cache-control:no-cache 服务器返回最新资源 压缩组件 web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持 Accept-Encoding:gzip,deflate 如果 web 服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来压缩响应。web 服务器通过响应中的 Content-Encoding 头来通知 web 客户端 Content-Encoding:gzip 代理缓存 当浏览器直接和服务器通信时，服务器基于Accept-Encoding 来检测是否对响应进行压缩，然后返回数据。 但是当浏览器发送请求给代理服务器时，情况会比较复杂。当请求的URL和请求方法相同时，浏览器会读取相同的缓存，但是这个缓存映射的可能是压缩或者没有压缩的数据，所以我们需要使用vary进行区分。这里有一个例子 假设客户端 A 请求了一个数据，且该客户端支持 gzip 压缩，于是请求头字段中带有 Accept-Encoding: gzip。 请求来到了代理服务器，但是里面没有缓存，所以代理服务器把请求又发送给了源服务器。源服务器拿到了请求报文，分析了一波，决定返回一个进行了 gzip 压缩的数据。另外，源服务器还希望介于它和客户端之间的代理服务器，也那能够像它一样优秀，可以根据 Accept-Encoding 返回正确的数据，于是在响应头字段中加上了 Vary: Accept-Encoding，并返回了数据A 给代理服务器。 数据A 来到了代理服务器，代理服务器取出了 Vary 字段，发现里面有个 Accept-Encoding，于是它明白了，它需要将当前响应报文的 Accept-Encoding 作为一个标志，映射到当前这个缓存数据A。即：URL + 请求方法 + \"Accept-Encoding: gzip\" -> 数据A 代理服务器缓存好了源服务器的数据后，并保存了映射关系，就把数据返回给了客户端 A。 很快，客户端 A 又发送相同请求，代理服务器接收了请求且缓存还没过期，且发现请求头依旧有 Accept-Encoding: gzip，于是缓存命中了数据A，数据A被返回给了客户端A。在缓存未过期的期间，只要任何一个客户端的请求头里有 Accept-Encoding: gzip且请求url，代理服务器返回的数据都是数据A。 不久后，不支持解压功能的客户端B 发送一个没有 Accept-Encoding 字段的请求。代理服务器拿到了数据，缓存没有命中，于是和上面一样，拿到一个新的缓存数据B，得到了一个新的映射关系：URL + 请求方法 + 无 Accept-Encoding 的头字段 -> 数据B 如果代理服务器不使用 Vary，纯粹只是根据 请求URL和请求方法 来判断是否缓存命中，那不支持解压功能的 客户端B 就可能会错误拿到代理服务器中的被压缩过的 数据A。 通过 Vary 头字段，我们可以避免客户端B拿到一个无法解压的数据A。 总结：vary 头字段的作用-让代理服务器的缓存命中更多的决定因子，而不仅仅是依据请求URL和请求方法来决定是否命中。 把样式表放在顶部 把样式表放在顶部可以避免 白屏 和 无样式内容的闪烁 注意不要使用 @import 引入样式表 问题一： 浏览器渲染流程 浏览器通过HTTP协议请求服务器，获取HTML文档并开始从上到下解析，构建DOM 在构建DOM过程中，如果遇到外联的样式表声明和脚本声明,则暂停HTML文档解析,创建新的网络连接,并开始下载样式文件和脚本文件 样式文件下载后,构建CSSDOM;脚本文件下载完成后,解释并执行,然后继续解析HTML文档构建DOM 完成HTML文档解析后,将DOM和CSSDOM进行关联和映射,最后将视图渲染到浏览器窗口. 问题二：@import 和 link 的区别 把脚本放在底部 浏览器可以并行地执行HTTP请求 HTTP 1.1 规范建议浏览器从每个主机名并行地下载两个组件。 但是下载脚本时并行下载实际上是被禁用的---即使使用了不同主机名，浏览器也不会启动其他的下载。 正是因为上面的原因，如果脚本放在顶部。那么脚本会阻塞对其后面内容的呈现，会阻塞对其后面组件的下载。 我们可以使用 defer 和async来控制脚本的执行 如果没有defer 和 async ，浏览器会进行脚本文件的下载和执行,它是和文档解析同步进行的，也就是说会阻塞文档的解析。 async 浏览器会异步下载脚本，并在允许的情况下执行，不会按照scripte在页面中的顺序执行，谁先加载完先执行谁。 defer 浏览器会异步下载脚本，并且不会影响后续DOM的渲染。会按照script在页面中的顺序执行 参考 避免CSS表达式 使用外部JavaScripte 和 CSS 减少DNS查找 影响DNS缓存的因素 DNS 记录存活时间 (TTL)，该值告诉客户端可以对该记录缓存多久。 浏览器对缓存的DNS记录的数量也有限制，而不管缓存记录的时间。 减少DNS查找 方法一： 较少的域名 当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等，包括页面URL、图片、脚本文件、样式表、Flash对象等的主机名。减少唯一主机名的数量可以减少DNS查找的数量。 但是减少唯一主机名的数量会潜在地减少页面中并行下载的数量，所以要做好权衡 方法二：使用keep-alive 通过重用现有连接，从而通过避免TCP/IP开销来减少响应时间 避免重定向 重定向用于将用户从一个URL重新路由到另一个URL。有很多种常用的是301和302 重定向的方法： 服务器返回301 302，浏览器会自动将用户带到 Location 字段所给出的URL.。 HTML文档的头中包含的 meta refresh 标签可以在其 content 属性所指定的秒数之后重定向用户 JavaScript 可以用于执行重定向，将 document.location设置为期望的 URL 即可 引发重定向： 缺少结尾的斜线，会导致301 连接网站，将旧网站连接到新网站，将一个网站的不同部分连接起来，基于一些条件(浏览器类型，用户账户类型等)来引导用户 跟踪内部流量 重定向经常用于跟踪用户流量的流向。 也可以选择 Referer 日志来跟踪流量去向。所以可以用referer来避免重定向 美化URL 移除重复脚本 配置ETag ETag 会产生性能问题，在不同的服务器上相同的文件 ETag 不同，会导致再次返回200而不是304 使Ajax可缓存 'Ajax' 表示异步的JavaScript 和 XML。 Ajax 不是一个单独的、需要许可证的技术，而是一组技术，包括JavaScripte、CSS、DOM和异步数据获取。 Ajax 在UI 和 Web 服务器之间插入了一层，整个Ajax层位于客户端，与Web服务器进行交互以获取请求信息，并于表现层交互，仅更新那些必要的组件。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/optimize/内存泄漏.html":{"url":"chapters/optimize/内存泄漏.html","title":"内存泄漏","keywords":"","body":"JavaScript 常见的内存泄漏 什么是内存泄漏 内存泄漏是指当一块内存不再被应用程序使用的时候，由于某种原因，这块内存没有返还给操作系统或者内存池的现象。内存泄漏可能会导致应用程序卡顿或者崩溃。 JS有两种变量，全局变量和局部变量，局部变量的生命周期在函数执行过后结束，这时可以垃圾回收 全局变量的生命周期会持续到浏览器关闭页面。 常见的内存泄漏 意外的全局变量 在非严格模式下，未定义的变量会自动绑定在全局对象上，当函数执行完毕后，这个变量本应该被销毁，但是因为已经绑定到了window上，无法被垃圾回收。 所有当我们使用完毕全局变量后，应该设置为null ，来让他被回收 被遗忘的计时器或回调函数 JS中引用DOM 用JSON键值对保存了DOM节点的数据结构，这个时候DOM元素存在两个引用：一个在DOM树中，另一个在字典中。当我们要删除这些DOM时，需要把两个引用都清除 如果保存了一个子节点，当我们删除这个DOM时会删不掉，因为子节点引用了父节点。 比如在JavaScript代码中保存了表格某一个td的引用，当我们删除整个表格时，以为会删除了除td以外的所有节点，其实不是，因为td是表格的子节点，子元素和父元素是引用关系，所以整个表格还在内存中 闭包 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/optimize/web.html":{"url":"chapters/optimize/web.html","title":"页面快速加载","keywords":"","body":"优化网页速度 优化图片资源的格式和大小 开启网络压缩 使用浏览器缓存 减少重定向请求 使用CDN存储静态资源 减少DNS查询次数 压缩CSS和JS内容 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/react/":{"url":"chapters/react/","title":"React","keywords":"","body":"React 方面 你真的是太强悍了 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/react/rn打包.html":{"url":"chapters/react/rn打包.html","title":"React-Native打包","keywords":"","body":"React-Native 打包 生成一个签名密钥 设置 gradle 变量 把签名配置加入到项目的gradle配置中 生成发行apk包 测试应用的发行版本 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/react/react生态.html":{"url":"chapters/react/react生态.html","title":"react生态","keywords":"","body":"react生态 路由 react-router 状态管理 redux UI库 ant design bfd-ui powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/react/react-hard.html":{"url":"chapters/react/react-hard.html","title":"react难点","keywords":"","body":"React 难点 开发中会遇到的问题 setState 是同步还是异步? 异步：在钩子函数和React合成事件中使用setState是异步 同步：在异步函数比如setTimeout和原生事件中使用setState是同步 为什么有时候连续两次setState只有一次生效? a) 直接传递对象的setState会被合并成一次 b) 使用函数传递state不会被合并 setState 执行过程 将setState传入的partialState参数存储在当前实例的state暂存队列中 判断当前React是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中 如果未处于批量更新状态，将批量更新状态标识设置为true,用事务再次调用前一步方法，保证当前组件加入了待更新组件队列中。 调用事务的wrap方法，遍历待更新组件队列依次执行更新 执行生命周期componentWillReceiveProps 将组件的state暂存队列中state进行合并，获得最终要更新的state对象，并将队列置为空 执行生命周期componentShouldUpdate,根据返回值判断是否要继续更新 执行生命周期componentWillUpdate 执行真正的更新render 执行生命周期componentDidUpdate powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/aiot-work/":{"url":"chapters/aiot-work/","title":"实习记录","keywords":"","body":"实习记录 记录在工作中的问题 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/aiot-work/七月.html":{"url":"chapters/aiot-work/七月.html","title":"七月","keywords":"","body":"7-8 今天做页面，发现对栅栏布局很不熟 7-10 前两天做的页面，yl哥一个封装的组件就分分钟搞定。。。 自己好low哈，要好好吃透这个组件！ 我现在明白了面经里为什么要考递归，三目运算符了。。 7-17 今天解决一个问题就是当没有权限时加载不了数据，同时提醒\"没有权限\"的提示语。我主要是改没有“没有权限”的提示语。 先说一下没有权限加载不了数据，当用户有某个权限，当请求数据时可以用token进行验证，也就是说用 token是通行证。 在解决提示语 1.查看当没有权限时，发回的消息。发现是状态码是200 但是消息中有code 401,message:'没有权限'。所以我们要验证 code 然后把 message 显示就可。 2.在代码中，发现状态码是200时不会抛错，但是原有的代码结构显示信息是在code不是200时，所以我们可以自己来验证一下code是401时,return Promise.reject({})这样就会抛到catch里，学到了 哈哈哈。 3.结构赋值，里面用到了很多复杂的结构赋值。这个地方得好好看看 4.debugger 这个太好用了！ 7月20日 因为我要做的页面是实时报警数据浏览，在用户浏览数据时，实时数据可能会改变。 实时获取数据，当后端数据变化时，前端渲染的数据也应该改变。 两种办法，轮询和websocker，都需要前后端配合来确定。 WebSocket WebSocket Web浏览器与Web服务器之间全双工通信标准。当Web服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。ws:// wss:// 为了实现 WebSocket,在HTTP连接建立之后，需要完成一次\"握手\"。 需要用到 HTTP 的 首部字段 Upgrade 首部字段告知服务器通信协议发生改变,以达到握手的目的。 Sec-WebSocket-Key 字段 内记录着握手 过程中必不可少的键值 Sec-WebSocket-Protocol 记录使用的子协议 GET /chat HTTP/1.1 Host: server.example.com Origin: http://example.com //浏览器 Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGHI..... Sec-WebSocket-Protocol: chat,superchat Sec-WebSocket-Version: 13 WebSocket 的简单实例 var ws = new WebSocket(\"wss://echo.websocket.org\"); ws.onopen = function(evt) { console.log('Connection open ...'); ws.send('Hello WebSockets') } ws.onmessage = function(evt) { console.log('Received Message:'+evt.data); ws.close() } ws.onclose = function(evt) { console.log(\"connection closed\") } WebSocket 对象是一个构造函数，用于新建 WebSocket 实例 var ws = new WebSocket('ws://localhost:8080') 执行上面语句 后，客户端就会与服务器连接 事件 open 当一个 WebSocket 连接成功时触发 close 当一个 WebSocket 连接关闭时触发 message 当通过 WebSocket 收到数据时触发 error 当一个 WebSocket 连接因错误而关闭时触发，例如无法发送数据时 方法 send 用于向服务器发送数据 ws.send('your message') 7月22日 今天全天都在改动一个Bug 这个问题其实上个星期遗留下来的，我本来已经放弃了，转移给了zj姐，然后发现了这个文档)，发现之前是自己思路错了在加上认为自己没有能力改好 感觉有一丝希望，就又承担了下来，改了一通下来，最大的感受就是，找到方法真的很重要。 7月23日 今天的项目问题，从报警工作台跳到报警详情页会携带一些参数，然后报警详情页根据这些参数进行请求。 但是一旦刷新这些参数就会被清除，所以我采用的办法是sessionStorage sessionStorage.setItem('type',this.props.location.type) sessionStorage.setItem('label'.this.props.location.label) 每次发请求时会判断一下 type label 是否是undefind 分页 前端分页，获取到所有的数据分页显示 moment() 真的强大！ moment().add(7,'h') 表示在当前的时间点加七个小时 7月24日 从工作台跳到实时报警页面通过location传入type,label字段，报警页面根据这两个字段请求数据，用户刷新再次请求时这两个字段还是存在的，所以我将这两个字段存在了sessionStorage中 但是当从侧边栏直接跳到报警页面的时候没有type,label字段，报警页面直接请求数据。 现在的问题是，如何让 从侧边栏和从工作台跳到报警页面能正确拿到 type和label ,并且在刷新的时候 type,label也不会被清除掉。 最后发现 用 search 就可 什么玩意！ 自己好菜 7月29号 今天解决了三个bug！ 又新增了一个页面，和之前的页面大同小异。 分页是个比较头疼的问题 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/aiot-work/八月.html":{"url":"chapters/aiot-work/八月.html","title":"八月","keywords":"","body":"8月5号 “报警”页面基本告一段落，等待测试通过在继续完善 今天有一个新任务 --- 基于antd 的 Select 组件封装一个适用于项目的 InputSelect 组件。在Select中需要呈现一个Table表单 需要实现下面几个基础功能 支持多选、单选 支持模糊搜索 表格请求数据组件内部维护 分页 8月17日 上个星期基本是在bug中度过的，很多样式上的问题，今天终于全部搞定！ 印象最深的一个是，当一个模态框从小模态框放大到整个屏幕时，因为这个模态框是通用的，所以里面内容有长有短，我们不能让模态框的content部分的高度用vh这样的单位来设置，而是应该动态添加类，来用height:100% 和 overflow:hidden控制。 8月19日 替换高级搜索组件，在本地环境测试没有问题，但是打包发布到线上会报错。 是因为打包将很多字段进行了简化，所以加了新的字段进行区别。 同时还是因为函数不可能和函数相等。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/webpack/":{"url":"chapters/webpack/","title":"前端工程化","keywords":"","body":"前端工程化 方面 主要是 webpack powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/webpack/ch01.html":{"url":"chapters/webpack/ch01.html","title":"webpack","keywords":"","body":"Webpack 概念 webpack 是一个现代 JavaScript 应用程序的静态模块打包器，当 webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle 四个核心 入口 entry 输出 output loader 插件 plugins loader 作用 loader 让 webpack 能够去处理那些非 JavaScript 文件 (webpack 自身只理解 JavaScript)。loader可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后使用 webpack 的打包能力，进行处理。本质上,webpack loader将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。 webpack 模块种类 ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 样式 (url(...)) 或HTML文件()中的图片链接 css /sass /less 文件中的 @import 语句 (突然想到，为什么每次都要配置css的loader一些，是因为css文件本身不是一个模块，但要是让他呈现样式一般会@import index.css这样，其实loader就是让css文件变成一个webpack 模块，这样才能使用@import进行引用) 使用 必须配置 test , use 属性 const path = require('path') const config = { output: { filename: 'my.js' }, module: { rules: [ {test:/\\.txt$/,use:'raw-loader'} ] } } module.exports = config; 插件 plugins 作用 插件🐂 🐂 可以进行打包优化、压缩、定义环境中的变量。。。也可以自己编写插件 使用 想要 使用一个插件，需要require()它，然后把他添加到 plugins 数组中。多数插件可以通过选项(option)自定义。也可以在一个配置文件中因为不同目的而多次使用同一个插件，这是需要通过使用 new 操作符来创建它的一个实例。 const HtmlWebpackPlugin = require('html-webpack-plugin'); const webpack = require('webpack'); const config = { module: { rules: [ {test: /\\.txt$/,use: 'raw-loader'} ] }, plugins: [ new HtmlWebpackPlugin({template:'./src/index.html'}) ] } module.exports = config; webpack环境 开发环境和生产环境，在开发环境中，需要强大的、具有实时重新加载或热模块替换能力的source map 和 localhost server 。而在生产环境中，则更关注更小的bundle，更轻量的source map ,以及更优化的资源。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/webpack/git.html":{"url":"chapters/webpack/git.html","title":"git常用命令","keywords":"","body":"git使用 创建新分支（本地和远程） git branch dev_bg git checkout dev_bg // 推送到远程分支 git push origin dev_bg 删除分支 // 删除本地dev_bg分支 git branch -d dev_bg // 删除远程dev_bg分支 git push origin -d dev_bg 查看分支 // 查看所有分支 git branch -a // 查看本地分支 git branch -l // 查看远程分支 git branch -r 合并代码 //1. 切换到合并的分支，比如在dev分支上开发，需要合并到master分支，则先 切换到master git checkout master //2. 合并代码 git merge dev //3. 查看是否冲突 git status //4. 再次拉一次远程代码 git pull origin master //5. 推送到远程 git push origin master 拉取分支 // 比如拉取远程 dev 分支到本地 //1. 先在本地新建dev分支 git checkout -b dev //2. 拉取远程分支 git pull origin dev 回退 // 1.查看版本号 git log // 2.根据版本号，将版本回退 git reset --hard 版本号 // 3.将远程仓库覆盖 git push origin 仓库名 -f powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/webpack/css模块化.html":{"url":"chapters/webpack/css模块化.html","title":"css模块化","keywords":"","body":"css模块化 React中CSS模块化 使用 css modules import React,{Component} from 'react' import CSSModules from \"react-css-modules\" import styles from \"assets/css/main.css\" class main extends Component{ constructor(props){ super(props) } render(){ return ( ) } } export default main //main.css .container{ ... } .child{ ... } 给每个页面根节点设置唯一类名，然后加上CSS后代选择器的方式来实现私有样式 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/data-structure/":{"url":"chapters/data-structure/","title":"数据结构","keywords":"","body":"数据结构 方面 大学三年最痛苦的一门课,自己好笨 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/algorithm/":{"url":"chapters/algorithm/","title":"算法","keywords":"","body":"算法 方面 又是一个硬骨头,leetcode 刷起来,起码得把剑指offer刷完 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/algorithm/快速排序.html":{"url":"chapters/algorithm/快速排序.html","title":"快速排序","keywords":"","body":"快速排序 基本思想 通过一趟排序将所要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，这个排序过程可以递归进行，以此达到整个数据变成有序序列。 代码实现 var arr = [5,6,4,3,7,8] function quickSort(arr,left,right){ if(left=prvot) j--; if(i>=j) break; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } arr[left] = arr[j]; arr[j] = prvot; return j; } console.log(quickSort(arr,0,arr.length-1)); powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/small/":{"url":"chapters/small/","title":"小题集","keywords":"","body":"小题集 代码 小题 笔试 小题 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/small/code.html":{"url":"chapters/small/code.html","title":"代码集","keywords":"","body":"代码集 函数柯里化 实现 add(1)(2)(3) function curry(fn,arg) { let len = fn.length; let args = arg || []; return function(){ let _args = Array.prototype.slice.call(arguments); [].push.apply(_args,args); if(_args.length 数组去重 方法一：set 与 结构赋值去重 function unique(arr) { return [...new Set(arr)] } 方法二：set 与 Array.from() 方法结合去重 注：Array.from() 类数组转化成数组 function unique(arr) { return Array.from(new Set(arr)) } 方法三：双重循环 function unique(arr) { for(let i=0; i 方法四：filter 去重 function unique(arr) { return arr.filter((item,index)=>{ return arr.indexOf(item) === index }) } 深拷贝 方法一 function deepClone(arr={}){ if(typeof arr !== 'object' || arr == null) { return arr } let obj; if(arr instanceof Array) { obj = [] }else{ obj = {} } for(let i in arr) { if(arr.hasOwnProperty(i)){ obj[i] = deepClone(arr[i]) } } return obj } 方法二 但是当 obj 存在函数时不能使用 JSON.parse(JSON.stringify(obj)) 防抖 一定时间段内没有触发事件，事件处理函数才会执行。如果在设定的时间段内触发事件，就重新开始延时。比如搜索发请求 function debounce(fn,time) { let timer = null; return function(){ if(timer != null){ clearTimeout(timer) } timer = setTimeout(fn,time) } } 节流 函数节流指阻止一个函数在短时间内被连续调用。只有当上一次函数执行后达到指定的时间间隔后，才能被再次调用 原理：使用定时器做时间节流。当触发一个事件时，先用setTimeout让这个事件延迟一小段时间后再执行，如果该事件在这个时间间隔中被再次触发，就clearTime上一个定时器，在setTimeout一个新的定时器重复以上的步骤。 function throttle(func,delay){ let timer; return function(...args){ if(timer){ clearTimeout(timer) } timer = setTimeout(()=>{ func.apply(this,args) },delay) } } 可以使用节流优化图片懒加载 手写 bind函数 利用apply函数实现bind函数 Function.prototype._bind = function(target){ let _this = this; let args = Array.prototype.slice.call(arguments,1); //let args = Array.from(arguments) //args.shift(); return function(){ return _this.apply(target,args) } } let obj = { name:'xx' } function test(args){ console.log('我的名字',this.name); console.log('接收的参数',args) } console.log(test._bind(obj,'I am args')()) 创建10个a标签，点击的时候弹出对应的序号 new的过程 拉平数组 function reduceArr(list){ let result = []; for(let i=0;i 找出一个数组中出现次数最多的元素 let arr = []; for(var i=0;i{ p[k]?p[k]++:p[k]=1; if(p[k]>max){ max = p[k]; num = k } return p; },{}) return num } console.log(findMore(arr)) 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制 Object.prototype.clone = function(){ var o = this.instanceof === 'Array'?[]:{}; for(var e in this){ o[e] = typeof this[e] === 'object' ? this[e].clone() : this[e] } return o } 获取以s或p开头的标签 使用递归 function dfs(node){ if(node.nodeType === 1){ let nodeName = node.nodeName.slice(0,1); if(nodeName === 'S' || nodeName === 'P'){ console.log(node) } let children = node.childNodes; for(let i=0,len=children.length;i 判断 [] 和 null instanceof console.log([] instanceof Object);//true console.log(null instanceof Object);//false !! !!null ;//false !![] ;//true Object.prototype.toString.call() Object.prototype.toString.call(null) ;// [Object Null] Object.prototype.toString.call([]) ;// [Object Array] 超出省略 .overflow{ width:200px; overflow:hidden; white-space:nowrap; text-overflow:ellipsis } powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/j4/":{"url":"chapters/j4/","title":"JavaScript高级程序设计4","keywords":"","body":"powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/j4/第十二章-BOM.html":{"url":"chapters/j4/第十二章-BOM.html","title":"第十二章-BOM","keywords":"","body":"BOM window BOM的核心是window对象，表示浏览器的实例。window对象在浏览器中有两种身份，ECMAScript中的Global对象和浏览器窗口的JavaScript接口。 窗口关系 top对象始终指向最上层，parent对象始终指向当前窗口的父窗口，self属性始终指向window 窗口位置 screenLeft,screenTop:表示窗口相对于屏幕左侧和顶部的位置 moveTo(),moveBy()：移动窗口 像素比 window.devicePixelRatio 表示物理像素与逻辑像素之间的缩放系数。比如手机屏幕的物理分辨率是1920x1080，但是因为其像素可能非常小，所以浏览器就需要将其分辨率降为较低的逻辑分辨率，必须640x320,这个物理像素与CSS像素之间的转换比例就是3,由window.devicePixelRatio提供。 窗口大小 innerWidth,innerHeight: 浏览器窗口中页面视口大小 outerwidth,outerHeight: 浏览器窗口自身大小 resizeTo(),resizeBy(): 调整窗口大小 视口位置 pageXoffset/scrollX，pageYoffset/scrollY: 度量文档相对于视口滚动距离的属性 scroll(),scrollTo(),scrollBy(): 滚动页面 导航与打开新窗口 window.open() 可以用于导航到指定的URL,也可以用于打开新窗口。接受四个参数：要加载的URL、目标窗口名、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。 如果“目标窗口名”已经存在，则会在该目标窗口打开URL 如果“目标窗口名”不存在，则会打开一个新的窗口“目标窗口名” 如果“目标窗口名“不存在，但是没有指定”特性字符串“，那么新打开的窗口会带所有默认参数 如果”目标窗口名“已经存在，也指定了”特性字符串“，那么新打开的窗口会忽略”特性字符串“ 特性字符串的位置 系统对话框 alert() confirm() promt() 这些对话框都是同步的模态对话框，即在他们显示的时候，代码会停止执行，在他们消失后，代码才会恢复执行 print() 显示打印对话框 find() 显示查找对话框 这两种对话框都是异步的 location location对象提供了当前窗口中加载文档的信息，以及通常的导航功能。它既是window的属性也是document的属性，window.location和document.location指向同一个对象。 'http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents' 属性 值 说明 location.hash \"#contents\" URL散列值，如果没有则为空字符 location.host \"www.wrox.com:80\" 服务器名及端口号 location.hostname \"www.wrox.com\" 服务器名 location.href \"http://www.wrox.com:80/WileyCDA/?q=javascript#content\" 当前加载页面的完整的URL location.pathname \"/WileyCDA/\" URL中的路径和(或)文件名 location.port “80” 请求的端口，如果URL中没有端口，则返回空字符串 location.protocol \"http:\" 页面使用的协议 location.search \"?q=javascript\" URL的查询字符串 location.username \"foouser\" 域前指定的用户名 location.password \"barpasswrod\" 域前指定的密码 location.origin “http://www.wrox.com” URL的源地址 查询字符串 URLSearchParams 提供一组标准API方法，通过他们可以检查和修改查询字符串。 给URLSearchParams构造函数传入一个查询字符串，就可以创建一个实例。这个实例上暴露了get()、set()、delete()等方法。 操作地址 location.assign('url')方法修改浏览器地址 window.location('url') location.href('url') 前面的三种方法，可以使用回退。使用location.replace('url')改变地址后，回退功能被禁用 location.reload('url'),能重新加载当前显示的页面，调用reload()而不传参数，页面会以最有效的方式重新加载。如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面，如果想强制从服务器重新加载，可以给reload传一个true 除了hash以外，只要修改location的一个属性，就会导致页面重新加载新URL navigator 检测插件 检测浏览器是否安装了某个插件可以通过plugins数组来确定，这个数组中的每一项都包含如下属性： ​ name:插件名称 ​ description:插件的文件名 ​ filename:插件的文件名 ​ length:由当前插件处理的MIME类型的数量 注册处理程序 registerProtocolHandler()方法可以把一个网站注册为处理某种特定类型信息应用程序，借助这个方法可以将Web应用程序注册为像桌面软件一样的默认应用程序。 传入三个参数：要处理的协议(如\"mailto\"或\"ftp\")、要处理该协议的URL，以及应用名称。 navigator.registerProtocolHandler(\"mailto\",\"http://www.somemailclient.com?cmd=%s\",\"some mail client\") screen 保存客户端信息 属性 说明 availHeight 屏幕像素高度减去系统组件高度 history history对象表示当前窗口首次使用以来用户的导航历史记录。 导航 go() 方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。 back() forward() length属性，表示历史记录中有多个条目 历史状态管理 hashchange 会在页面URL的散列变化时被触发，状态管理API可以让开发者改变浏览器URL而不会加载新页面，可以使用history.pushState()方法，接收三个参数：一个state对象、一个新状态的标题和一个(可选的)相对URL。 pushState 和 replaceState() 需要在理解 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/j4/第十三章-客户端检测.html":{"url":"chapters/j4/第十三章-客户端检测.html","title":"第十三章-客户端检测","keywords":"","body":"powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/j4/第十四章-DOM.html":{"url":"chapters/j4/第十四章-DOM.html","title":"第十四章-DOMvue","keywords":"","body":"第十四章-DOM 文档对象模型(DOM)的构成 节点类型 Node是基准节点类型，是文档一个部分的抽象表示，所有其他类型都继承Node Document 类型表示整个文档，对应树形结构的根节点。在JavaScript中,document对象是Document的实例，拥有查询或获取节点的很多办法 Element 节点表示文档中所有HTML或XML元素，可以用来操作他们的内容和属性 其他节点类型分别表示文本内容、注释、文档类型，CDATA区块和文档片段 DOM 描述了名为Node 的接口，这个接口是所有DOM节点类型必须实现的。Node接口在JavaScript中被实现为Node类型，所有节点类型都继承Node类型，因此所有类型都共享相同的基本属性和方法。 每个节点都要nodeType属性，表示该节点的类型 nodeName,nodeValue 保存节点信息。这两个属性的值完全取决于节点类型 节点关系：parentNode,previousSibling,nextSibling,firstChild,lastChild,childNodes 操纵节点: appendChild(),insertBefore(),replaceChild(),removeChild cloneNode 复制节点 normalize()处理文档子树中的文本节点 Document类型是JavaScript中表示文档节点的类型。在浏览器中，文档对象document是HTMLDocument的实例，表示整个HTML页面。 nodeType 为 9 nodeName 为 \"#document\" nodeValue 为 null parentNode 为 null ownerDocument 为 null document.documentElement始终指向页面中的html元素 document.body始终指向body元素 document.doctype 访问标签 document.title 浏览器窗口标题栏 document.URL document.referrer(链接到当前页面的那个页面的URL) document.domain(页面的域名)：domain是可以设置的。如果URL包含子域名如p2p.wrox.com，则可以将domian设置为\"wrox.com\"，不能给这个属性设置URL中不包含的值。当页面中包含来自某个不同子域的窗格(frame)或内嵌窗格(ifame)时，因为跨源通信存在隐患，所以不同子域的页面无法通过JavaScript通信，此时，在每个页面上把document.domain设置为相同的值，这些页面就可以访问对方的JavaScript对象了，比如，一个加载自 www.wrox.com 的页面中包含一个内嵌窗格，其中的页面加载自 p2p.wrox.com。这两个页面的 document.domain 包含不同的字符串，内部和外部页面相互之间不能 访问对方的 JavaScript 对象。如果每个页面都把 document.domain 设置为 wrox.com，那这两个页面 之间就可以通信 HTMLCollection对象namedItem()方法可以通过标签的name属性取得某一项的引用。 要取得文档中的所有元素，可以给getElementsByTagName()传入* getElementsByName()会返回具有给定name属性的所有元素 特殊集合:document.anchors包含文档中所有带name属性的a元素，document.form包含文档中所有form元素，document.images包含文档中所有img元素,document.links包含文档中所有带href属性的a元素 document.implementation ：由于DOM有多个leval和多个部分，因此确定浏览器实现了DOM的那些部分是很必要的，可以使用document.implementation来实现，document.implementation上hasFeature()方法，这个方法接收两个参数：特性名称和DOM版本 文档写入：向网页输出流中写入内容，write()，writeln()，open()，close() Element类型表示XML或HTML元素，对外暴露出访问元素标签名、子节点和属性的能力。 nodeType 为 1 nodeName 为 元素的标签名 nodeValue 为 null parentNode 为 Document 或 Element 对象 HTML元素都有下面的标准属性 id，元素在文档中的唯一标识符 title，包含元素的额外信息，通常以提示条形式展示 lang，元素内容的语言代码 dir，语言的书写方向(\"ltr\"表示从左到右，\"rtl\"表示从右到左) className 属性方法:getAttribute() setAttribute() removeAttribute() attributes 属性：Element类型是唯一使用attributes属性的DOM节点。attributes属性包含一个NamedNodeMap实例，是一个类似NodeList的“实时”集合。元素的每个属性都表示为一个Attr节点，并保存在这个NamedNodeMap对象中。NamedNodeMap对象包含下列方法 getNamedItem(name)，返回nodeName属性等于name的节点 removeNamedItem(name)，删除nodeName属性等于name的节点 setNamedItem(node)，向列表中添加node节点，以其nodeName为索引 item(pos)，返回索引位置pos处的节点 element.attributes.getNamedItem('id').nodeValue 创建元素 document.createElement() Text类型包含按字面解释的纯文本，也可能包含转义后的HTML字符，但不包含HTML代码。 nodeType 为 3 nodeName 为 \"#text\" nodeValue 为节点中包含的文本 Text节点中包含的文本可以通过nodeValue属性访问，也可以通过data属性访问，这两个属性包含相同的值。修改nodeValue或data的值，也会在另一个属性反映出来 文本节点操作文本的方法 appendData(text)，向节点末尾添加文本text deleteData(offset,count)，从位置offset开始删除count个字符 insertData(offset,text)，在位置offset插入text replaceData(offset,count,text)，用text替换从位置offset到offset+count的文本 splitText(offset)，在位置offset将当前文本节点拆分为两个文本节点 substringData(offset,count)，提取从位置offset到offset+count的文本 Comment类型是注释类型 nodeType等于8 nodeName 值为 ’#comment‘ nodeValue值为 注释的内容 parentNode 值为Document或Element对象 浏览s器兼容性 MutationObserver 接口 MutationObserver 接口可以在DOM被修改时异步执行回调。 基本用法 MutationObserver的实例要通过调用MutationObserver构造函数并传入一个回调函数来创建 let observer = new MutationObserver(() => console.log('DOM was mutated')) 新创建的MutationObserver实例不会关联DOM的任何部分，需要使用observe()方法将要观察的DOM关联起来，observer.observe(document.body,{attribute:true});这时,body元素上的任何属性变化都会被这个MutationObserver实例发现，然后异步执行注册的回调函数。 每个回调函数都会收到一个MutationRecord实例的数组。MutationRecord实例包含的信息包括发生了什么变化，以及DOM的哪一部分受到了影响。如果连续改变会生成多个MutationRecord实例，下次回调执行时就会收到包含所有这些实例的数组，顺序为变化事件发生的顺序。 MutationRecord实例的属性 属性 说明 target 被修改影响的目标节点 type 字符串，表示变化的类型:\"attributes\"、\"characterData\"或\"childList\" oldValue 如果在MutationObserverInit对象中启用(attributeOldValue或characterDataOldValue为true),\"attributes\"或\"characterData\"的变化事件会设置这个属性为被替代的值。childList类型的变化始终将这个属性设置为null attributeName 对于\"attributes\"类型的变化，这里保存被修改属性的名字。其他变化事件会将这个属性设置为null attributeNamespace 对于使用了命名空间的\"attributes\"类型的变化，这里保存被修改属性的名字。其他变化事件会将这个属性设置为null addedNodes 对于\"childList\"类型的变化，返回包含变化中添加节点的NodeList。默认为空NodeList removedNodes 对于\"childList\"类型的变化，返回包含变化中删除节点的NodeList。默认为空NodeList previousSibling 对于\"childList\"类型的变化，返回变化节点的前一个同胞Node,默认为null nextSibling 对于\"childList\"类型的变化，返回变化节点的后一个同胞Node,默认为null 传给回调函数的第二个参数是观察变化的MutationObserver的实例。 let observer = new MutationObserver((mutationRecords,mutationObserver)=>console.log(mutationRecords,mutationObserver)); observer.observe(document.body,{attribute:true}); document.body.className = 'foo' 默认情况下，只要被观察的元素不被垃圾回收，MutationObserver的回调就会响应DOM变化事件，从而被执行。要提前终止执行回调，可以调用disconnect()方法。但因为它是同步方法，所以不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调，可以使用setTimeout进行操作。 多次调用observe()方法，可以复用一个MutationObserver对象观察多个不同的目标节点。此时，MutationRecord的target属性可以标识发生变化事件的目标节点。 调用disconnect()并不会结束MutationObserver的生命，还可以重新使用这个观察者，再将它关联到新的目标节点 MutationObserverInit对象用于控制对目标节点的观察范围。观察者可以观察的事件包括属性变化、文本变化和子节点变化。 MutationObserverInit对象的属性 属性 说明 subtree 布尔值，表示除了目标节点，是否观察目标节点的子树。如果是false，则只观察目标节点的变化；如果是true，则观察目标节点及其整个子树。默认是false attributes 布尔值，表示是否观察目标节点的属性变化。默认是false attributeFilter 字符串数组，表示要观察那些属性的变化。把这个值设置为true也会将attributes的值转换为true，默认为观察所有属性 attributeOldValue 布尔值，表示MutationRecord是否记录变化之前的属性值。把这个值设置为true也会将attributes的值转换为true。默认为false characterData 布尔值，表示修改字符串数据是否触发变化事件 characterDataOldValue 布尔值，表示MutationRecord是否记录变化之前的字符数据。把这个值设置为true也会将characterData的值转换为true。默认为false childList 布尔值，表示修改目标节点的子节点是否触发变化事件。默认为false 在调用observe()时，MutationObserverInit对象中的attribute、characterData和childList属性必须至少有一项为true MutationObserver 接口只是出于性能考虑而设计，其核心是异步回调与记录队列模型。为了在大量变化事件发生时而不影响性能，每次变化的信息会保存在MutationRecord实例中，然后添加到记录队列。这个队列对每个MutationObserver实例都是唯一的，是所有DOM变化事件的有序列表。 记录队列 每次MutationRecord被添加到MutationObserver的记录队列时，仅当之前没有排期的微任务回调时(队列中微任务长度为0)，才会将观察者注册的回调作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。不过在回调的微任务异步执行期间，有可能又发生更多变化事件。因此被调用的回调会接收到一个MutationRecord实例的数组，顺序为他们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些MutationRecord就用不着了，因此记录队列会被清空，其内容会被丢弃。 takeRecords()方法 调用MutationObserver实例的takeRecords()方法可以清空记录队列，取出并返回其中的所有MutationRecord实例。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/j4/第十六章-DOM2和DOM3.html":{"url":"chapters/j4/第十六章-DOM2和DOM3.html","title":"第十六章-DOM2和DOM3","keywords":"","body":"DOM2和DOM3 DOM2和DOM3是按照模块化思路来制定标准的，每个模块之间有一定关联，但分别针对某个DOM子集。 DOM Core：在DOM1核心部分的基础上，为节点增加方法和属性 DOM Views：定义基于样式信息的不同视图 DOM Events：定义通过事件实现DOM文档交互 第十七章 DOM Style：定义以编程方式访问和修改CSS样式的接口 DOM Traversal and Range：新增遍历DOM文档及选择文档内容的接口 DOM HTML：在DOM1 HTML部分的基础上，增加属性、方法和新接口 DOM Mutation Observers：定义基于DOM变化触发回调的接口 第十四章 XML命名空间 XML 命名空间可以实现在一个格式规范的文档中混用不同的XML语言，而不必担心元素命名冲突。 命名空间是使用xmlns指定的。XHTML的命名空间是\"http://www.w3.org/1999/xhtml\"，该包含在任何格式规范的XHTML页面的html元素中，如下 Example Hello world! 上面所有元素都默认属于XHTML命名空间，可以使用xmlns给命名空间创建一个前缀，格式为\"xmlns:前缀\" Example Hello world! xhtml:body> 如果文档中只使用一种XML语言，那么命名空间前缀是多余的，只有一个文档混合使用多种XML语言时才有必要。比如使用了XHTML和SVG两种语言。对于这样的文档，如果调用某个方法与节点交互，就会出现问题，比如创建一个新元素，这个元素属于哪个命名空间？查询特定标签名时，结果中应该包含哪个命名空间下的元素？ 在DOM2中，Node类型包含一下特定于命名空间的属性： localName，不包含命名空间前缀的节点名 namespaceURI，节点的命名空间URI，如果未指定则为null prefix，命名空间前缀，如果未指定则为null 在节点使用命名空间前缀的情况下，nodeName等于prefix+\":\"+localName 在DOM3中，又增加了命名空间相关的方法 isDefaultNamespace(namespaceURI)，返回布尔值，表示namespaceURI是否为节点的默认命名空间 lookupNamespaceURI(prefix)，返回给定prefix的命名空间URI lookupPrefix(namespaceURI)，返回给定namespaceURI的前缀 在DOM2中，Document类型新增了下面的方法 createElementNS(namespaceURI,tagName)，以给定的标签名tagName创建指定命名空间namespaceURI的一个新元素 createAttributeNS(namespaceURI,attributeName)，以给定的属性名attributeName创建指定命名空间namespaceURI的一个新属性 getElementsByTagNameNS(namespaceURI,tagName)，返回指定命名空间namespaceURI中所有标签名为tagName的元素的NodeList DOM2对Element类型的更新 getAttributeNS(namespaceURI,localName)，取得指定命名空间namespaceURI中名为localName的属性 getAttributeNodeNS(namespaceURI,localName)，取得指定命名空间namespaceURI中名为localName的属性节点 getElementsByTagNameNS(namespaceURI,tagName)，取得指定命名空间namespaceURI中标签名为tagName的元素的NodeList hasAttributeNS(namespaceURI,localName)，返回布尔值，表示元素中是否有命名空间namespaceURI下名为localName的属性 removeAttributeNS(namespaceURI,localName)，删除指定命名空间namespaceURI中名为localName的属性 setAttributeNS(namespaceURI,qualifiedName,value)，设置指定命名空间namespaceURI中名为qualifiedName的属性为value setAttributeNodeNS(attNode)，为元素设置（添加）包含命名空间信息的属性节点attNode。 NamedNodeMap也增加了处理命名空间的方法，因为NamedNodeMap主要表示属性，所以这些方法大都适用于属性 getNamedItemNS(namespaceURI,localName)，取得指定命名空间namespaceURI中名为localName的项 removeNamedItemNS(namespaceURI,localName)，删除指定命名空间namespaceURI中名为localName的项 setNamedItemNS(node)，为元素设置（添加）包含命名空间信息的节点 下面的内容与XML命名空间无关，主要关注DOM API的完整性和可靠性 DocumentType新增了三个属性:publicId,systemId和internalSubset。 publicId、systemId属性表示文档类型声明中有效但无法使用DOM1 API访问的数据。 importNode()方法，它的目的是从其他文档获取一个节点并导入到新文档，以便将其插入新文档。每个节点都有一个ownerDocument属性，表示所属文档。如果调用appendChild()方法时传入节点的ownerDocument不是指向当前文档，则会发生错误。而调用importNode()导入其他文档的节点会返回一个新节点，这个新节点的ownerDocument属性是正确的。 importNode()方法跟cloneNode()类似，接收两个参数：要复制的节点和表示是否同时复制子树的布尔值，返回结果是适合在当前文档中使用的新节点 DOM2 View 给Document类型增加了新属性defaultView，是一个指向拥有当前文档的窗口（或窗格frame）的指针,IE8及更早版本支持等价的parentWindow属性。因此要确定拥有文档的窗口，可以使用以下代码 let parentWindow = document.defalutView || document.parentWindow 除了上面这一个方法和一个属性，DOM2 Core还针对document.implementation对象增加了createDocumentType()和createDocument()。createDocumentType()用于创建DocumentType类型的新节点，接收3个参数：文档类型名称、publicId和systemId。createDocument()用于创建新文档，接收3个参数：文档元素namespaceURI，文档元素的标签名和文档类型 DOM3给Node类型新增了两个用于比较节点的方法：isSameNode()和isEqualNode()。isSameNode()用于比较节点相同，引用同一个对象；isEqualNode()用于比较节点相等，意味着节点类型相同，拥有相同的属性(nodeName,nodeValue)，而且attributes和childNodes也相等。 DOM3也增加了给DOM节点附加额外数据的方法-setUserData()，接收3个参数：键、值、处理函数，用于给节点追加数据。 document.body.setUserData(\"name\",\"Nicholas\",function(){}) 然后，可以通过相同的键再取得这个信息 let value = document.body.getUserData(\"name\") setUserData()的处理函数会在包含数据的节点被复制、删除、重命名或导入其他文档的时候执行，可以在这个时候决定如何处理用户数据。处理函数接收5个参数：表示操作类型的数值(1代表复制，2代表导入，3代表删除，4代表重命名)、数据的键、数据的值、源节点和目标节点。删除节点时，源节点为null；除复制节点外，目标节点都为null 内嵌窗格的变化 iframe新增了一个contentDocument属性，这个属性包含代表子内嵌窗格中内容的document对象的指针。 let iframe = document.getElementById('myIframe'); let iframeDoc = iframe.contentDocument; contentDocument属性是Document的实例，拥有所有文档属性和方法，因此可以像使用其他HTML文档一样使用它。还有一个contentWindow，返回相应窗格的window对象，这个对象上有一个document属性 样式 HTML中的样式有3种定义方式：外部样式表（通过link标签），文档样式表（通过style标签），元素特定样式（通过style属性） 任何支持style属性的HTML元素在JavaScript中都会有一个对应的style属性。这个style属性是CSSStyleDeclaration类型的实例，其中包括通过HTMLstyle属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式继承来的样式。 DOM2 Style规范在style对象上定义了一些属性和方法。这些属性和方法提供了元素style属性的信息并支持修改 cssText，包含style属性中的CSS代码，可以读取/写取 length，应用给元素的CSS属性数量 parentRule，表示CSS信息的CSSRule对象 getPropertyPriority(propertyName)，如果CSS属性propertyName使用了!important则返回\"important\"，否则返回空字符串 getPropertyValue(propertyName)，返回属性propertyName的字符串值 item(index)，返回索引为index的CSS属性名 removeProperty(propertyName)，从样式中删除CSS属性propertyName setProperty(propertyName,value,priority)，设置CSS属性propertyName的值为value，priority是\"important\"或空字符串 计算样式 style对象中包含支持style属性的元素为这个属性设置的样式信息，但不包含从其他样式表层叠继承的同样影响该元素的样式信息。DOM2 Style在document.defaultView上增加了getComputedStyle()方法。这个方法接收两个参数：要取得计算样式的元素和伪元素字符串（如\":after\"）。如果不需要查询伪元素，则第二个参数可以传null。getComputedStyle()方法返回一个CSSStyleDeclaration对象(与style属性的类型一样)，包含元素的计算样式 Computed Styles Example #myDiv { background-color: blue; width: 100px; height: 200px; } 上面的div元素从style标签和自己的style属性获取了样式，此时，这个元素的style对象中包含backgroundColor和border属性，但不包含width和height属性。下面的代码从这个元素获取了样式 let myDiv = document.getElementById('myDiv'); let computedStyle = document.defaultView.getComputedStyle(myDiv,null); console.log(computedStyle.width) 操作样式表 CSSStyleSheet类型表示CSS样式表，包括使用link标签和通过style标签定义的样式表。这两个标签本身分别是HTML Link Element和HTMLStyleElement。CSSStyleSheet类型是一个通用样式表类型，可以表示以任何方式在HTML中定义的样式表。 CSSStyleSheet类型继承StyleSheet，后者可用作非CSS样式表的基类。以下是CSSStyleSheet从StyleSheet继承的属性。 disabled，布尔值，表示样式表是否被禁用了（这个属性是可读写的，因此将他设置为true会禁用样式表） href，如果是使用link包含的样式表，则返回样式表的URL，否则返回null media，样式表支持的媒体类型集合，这个集合有一个length属性和一个item()方法，跟所有DOM集合一样。同样跟所有DOM集合一样，也可以使用中括号访问集合中特定的项。如果样式表可用于所有媒体，则返回空列表 ownerNode，指向拥有当前样式表的节点，在HTML中要么是link元素要么是style元素，如果当前样式是通过@import被包含在另一个样式表中，则这个属性值为null parentStyleSheet，如果当前样式表是通过@import被包含在另一个样式表中，则这个属性指向导入它的样式表。 title，ownerNode的title属性 type，字符串，表示样式表的类型，对CSS样式表来说，就是'text/css' cssRules，当前样式表包含的样式规则的集合 ownerRule，如果样式表是使用@import导入的，则指向导入规则，否则为null deleteRule(index)，在指定位置删除cssRules中的规则 insertRule(rule,index)，在指定位置向cssRules中插入规则 document.styleSheets表示文档中可用的样式表集合。这个集合的length属性保存着文档中样式表的数量，而每个样式表都可以使用中括号或item()方法获取。 CSS规则 CSSRule类型表示样式表中的一条规则，这个类型也是一个通用基类，很多类型都继承它，但其中最常用的是表示样式信息的CSSStyleRule cssText，返回整条规则的文本。 parentRule，如果这条规则被其他规则包含，则指向包含规则，否则就是null。 parentStyleSheet，包含当前规则的样式表 selectorText，返回规则的选择符文本。 style，返回CSSStyleDeclaration对象，可以设置和获取当前规则中的样式 type，数值常量，表示规则类型 创建规则 DOM规定，可以使用insertRule()方法向样式表中添加新规则。 sheet.insertRule(\"body {background-color:silver}\",0) 元素尺寸 偏移尺寸 offsetHeigth，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度和上下边框的高度 offsetWidth，元素在水平方向上占用的像素尺寸，包括它的宽度、垂直滚动条宽度和左右边框的宽度 offsetLeft，元素左边框外侧距离包含元素左边框内侧的像素数 offsetTop，元素上边框外侧距离包含元素上边框内测的像素数 其中offsetLeft和offsetTop是相对于包含元素的 客户端尺寸 元素的客户端尺寸包含元素内容及其内边距占用的空间。 clientHeight，内容区域高度加上、下内边距的高度 clientwidth，内容区域宽度加左、右内边距的宽度 不包含滚动条占用的空间 滚动尺寸 滚动尺寸提供了元素内容滚动距离的信息，有些元素，比如html无须任何代码就可以自动滚动，而其他元素则需要使用css的overflow属性令其滚动。 scrollHeight，没有滚动条出现时，元素内容的总高度 scrollWidth，没有滚动条出现时，元素内容的总宽度 scrollLeft，内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置 scrollTop，内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置 元素尺寸 浏览器在每个元素上都暴露了getBoundingClientRect()方法，返回一个DOMRect对象，包含6个属性:left、top、right、bottom、height和width。 遍历 DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历DOM结构。这两个类型--NodeIterator和TreeWalker---从某个起点开始执行对DOM结构的深度优先遍历 NodeIterator 类型可以通过document.createNodeIterator()方法创建实例。接收4个参数 root ，作为遍历根节点的节点 whatToShow，数值代码，表示应该访问哪些节点 filter，NodeFilter对象或函数，表示是否接收或跳过特定节点 entityReferenceExpansion，布尔值，表示是否扩展实体引用 whatToShow 参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。这个参数对应的常量是在NodeFilter类型中定义的 NodeFilter.SHOW_ALL，所有节点 NodeFilter.SHOW_ELEMENT，元素节点 。。。 这些值除了NodeFilter.SHOW_ALL 之外，都可以组合使用 let whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT filter参数可以用来指定自定义NodeFilter对象，或者一个作为节点过滤器的函数。NodeFilter对象只有一个方法acceptNode()，如果给定节点应该访问就返回NodeFilter.FILTER_ACCEPT，否则返回NodeFilter.FILTER_SKIP。因为NodeFilter是一个抽象类型，所以不可能创建它的实例。只要创建一个包含acceptNode()的对象，然后把它传给createNodeIterator()就可以。 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/vue/vue.html":{"url":"chapters/vue/vue.html","title":"Vue.js","keywords":"","body":"每个Vue应用都是通过Vue函数创建一个新的Vue实例开始 var vm = new Vue({ //选项 }) 当一个Vue实例被创建时，它将data对象中的所有的property加入到Vue的响应系统中。当这些property的值发生改变时，视图将会“响应”，即匹配更新为新的值。 Object.freeze() 会阻止修改现有的property，意味着不能响应 除了数据property，Vue实例还暴露了一些有用的实例property与方法。他们都有前缀$，以便与用户定义的property区分开 比如 $data，$el，$watch 生命周期钩子 created 实例被创建之后 Vue.js使用了基于HTML的模板语法，允许开发者声明式的将DOM绑定至顶层Vue实例的数据。所有Vue.js的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML解析器解析 在底层的实现上，Vue将模板编译成虚拟DOM渲染函数。结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。 v-once指令，能执行一次性地插值，当数据改变时，插值处的内容不会更新。 v-html指令，会输出真正的HTML 双大括号语法叫\"Mustache\"语法 Mustache语法不能作用在HTML attribute上，遇到这种情况应该使用v-bind指令 属性 Vue提供了一种更通用的方式来观察和响应Vue实例上的数据变动：侦听属性。当你有一些数据需要随着其他数据变动而变动时，会很容易滥用watch---。通常更好的做法是使用计算属性而不是命令式的watch回调。 计算属性默认只有getter，可以在需要时提供一个setter computed:{ fullName:{ get:function(){ return this.firstName + ' ' + this.lastName }, set:function(newValue){ var names = newValue.split(' '); this.firstName = names[0]; this.lastName = names[names.length-1] } } } vm.fullName = 'John Doe' 当运行 vm.fullName = 'John Doe',setter会被调用 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么Vue通过watch选项提供了一个更通用的方法来响应数据的变化，当需要在数据变化时执行异步或开销较大的操作时，这个方式最有用 Class与Style绑定 操作元素的class列表和内联样式是数据绑定的一个常见需求。因为他们都是attribute，所以我们可以用v-bind处理他们：只需要通过表达式计算出字符串结果即可。表达式结果的类型除了字符串之外，还可以是对象或数组。 我们可以传给v-bind:class一个对象，动态的切换class: 上面的语法表示active这个class存在与否将取决于数据property isActive的真值 可以在对象中传入更多字段来动态切换多个class，此外,v-bind:class指令也可以与普通的class attribute共存。 绑定的数据对象不必内联定义在模板里 data:{ classObject:{ active:true, 'text-danger':false } } 也可以在这里绑定一个返回对象的计算属性 data:{ isActive:true, error:null }, computed:{ classObject:function(){ return { active:this.isActive && !this.error, 'text-danger':this.error && this.erro.type === \"fatal\" } } } 数组语法 data:{ activeClass:'active', errorClass:'text-danger' } 如果想根据条件切换列表中的class,可以用三元表达式 在数组语法中也可以使用对象语法 对象语法 v-bind:style的对象语法十分直观，CSS property名可以用驼峰式或短横线分割来命名 data:{ activeColor:'red', fontSize:30 } 直接绑定在一个样式对象上通常更好 data:{ styleObject:{ color:'red', fontSize:30 } } v-bind:style的数组语法可以将多个样式对象应用到同一元素上 自动添加前缀 当v-bind:style使用需要添加浏览器引擎前缀的CSS property，如transform，Vue.js会自动侦测并添加相应的前缀 多重值 可以为style绑定中的property提供一个包含多个值的数组，常用于提供多个带前缀的值 条件渲染 v-if 指令用于条件性渲染一块内容。这块内容只会在指令的表达式返回truthy值的时候被渲染 Vue is awsome! 也可以用v-else添加一个\"else块\" Vue is awesome! oh no 在template元素上使用v-if条件渲染分组 因为v-if是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个template元素当作不可见的包裹元素，并在上面使用v-if。最终的渲染结果将不包含template元素 Title Paragraph 1 可以使用v-else指令来表示v-if的\"else\"块 0.5\"> Now you see me Now you don't v-else元素必须紧跟在带v-if或v-else-if的元素的后面，否则不会被识别 v-else-if v-else-if顾名思义，充当'v-if'的‘else-if'块，可以连续使用 A B C 用key管理可复用的元素 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使Vue变得非常快之外，还有其他一些好处 允许用户在不同的登陆方式之间切换 Username Email 那么在上面的代码中切换loginType将不会清除用户已经输入的内容，因为两个模板使用了相同的元素，input不会被替换掉，仅仅替换它的placeholder。这样也不总是符合实际需求，所以Vue提供了一种方式来表达”这两个元素是完全独立的，不要复用它们“，只需要添加一个具有唯一值的key attribute 即可 现在每次切换时，输入框都将被重新渲染。注意，label元素仍然会被高效地复用，因为他们没有添加key attribute v-show 另一个用于根据条件展示元素的选项是v-show指令。用法大致一样 Hello v-show不支持template元素，也不支持v-else v-if VS v-show v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if也是惰性的：如果在初始渲染时条件为假，则什么也不做---直到条件第一次变为真时，才会开始渲染条件 相比之下，v-show就简单的多---不管初始条件是什么，元素总是被渲染，并且只是简单地基于CSS进行切换 一般来说，v-if 有更高的切换开销，而v-show有更高的初始渲染开销。 因此，如果需要非常频繁的切换，则使用v-show较好，如果在运行时条件很少改变，则使用v-if较好 不推荐v-if与v-for一起使用，如果一起使用，v-for具有比v-if更高的优先级 列表渲染 用v-for把一个数组对应为一组元素 我们可以用v-for指令基于一个数组来渲染一个列表，v-for指令需要使用item in items 形式的特殊语法，其中items 是源数据数组，而item则是被迭代的数组元素的别名 {{item.message}} 在v-for块中，我们可以访问所有父作用域的property，v-for还支持一个可选的第二个参数，即当前项的索引 {{parentMessage}} - {{index}} - {{item.message}} 以可以用of替代in 作为分隔符 在 v-for里使用对象 可以用v-for来遍历一个对象的property {{value}} 也可以提供第二个参数为property名称 {{name}}:{{value}} 当Vue正在更新使用v-for渲染的元素列表时，它默认使用“就地更新”的策略，如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并且确保他们在每个索引位置正确渲染。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时DOM（例如：表单输入值）的列表渲染输出。为了给Vue一个提示，以便他能跟踪每个节点的身份，从而重用和重新排序现有元素，我们可以为每项提供一个唯一 key attribute 建议尽可能在使用v-for时提供key attribute，除非遍历输出的DOM内容非常简单，或者是可以依赖默认行为以获取性能上的提升 因为它是Vue识别节点的一个通用机制,key并不仅与v-for特别关联。 数组更新检测 变更方法 Vue将被侦听的数组的变更方法进行了包裹，所以他们也将会触发视图更新。这些被包裹过的方法包括： push() pop() shift() unshift() splice() sort() reverse() 替换数组 变更方法，会变更调用了这些方法的原始数组。相比之下，也有非变更方法。例如filter()、concat()和slice()，他们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组。 example1.items = example1.items.filter(function(item){ return item.message.match(/Foo/) }) 你可能认为这将导致Vue丢弃现有DOM并重新渲染整个列表，幸运的是，事实并非如此，Vue为了使得DOM元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作 显示过滤/排序后的结果 有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据，在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。 {{n}} data:{ numbers:[1,2,3,4,5] }, computed:{ eventNumbers:function(){ return this.numbers.filter(function(number){ return number%2 === 0 }) } } 在计算属性不适用的情况下(例如，在嵌套v-for循环中)可以使用一个方法 {{n}} data:{ sets:[[1,2,3,3,4],[6,7,8,9,10]] }, methods:{ even:function(numbers){ return numbers.filter(function(number){ return number % 2 === 0 }) } } v-for也可以接受整数，在这种情况下，它会把模板重复对应次数 {{n}} 在template上使用v-for 类似于v-if ，可以利用带有v-for的template来循环一段包含多个元素的内容 {{item.msg}} v-for和v-if一同使用 当我们处于同一节点，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用 {{todo}} 上面的代码将只渲染未完成的todo 而如果你的目的是有条件地跳过循环的执行，那么可以将v-if置于外层元素(或) 事件处理 监听事件 可以用v-on指令监听DOM事件，并在触发时运行一些JavaScript代码 事件处理方法 然而很多事件处理逻辑会更为复杂，所以直接把JavaScript代码写在v-on指令中是不可行的。因此v-on还可以接收一个需要调用的方法名称 内联处理器中的方法 除了直接绑定到一个方法，也可以在内联JavaScript语句中调用方法 有时也需要在内联语句处理器中访问原始的DOM事件，可以用特殊变量$event把它传入方法 事件修饰符 在事件处理程序中调用event.preventDefault()或event.stopPropagation()是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理DOM事件细节。为了解决这个问题，Vue.js为v-on提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的 .stop .prevent .capture .self .once .passive 阻止单击事件继续传播 提交事件不再重载页面 修饰符可以串联 只有修饰符 添加事件监听器时使用事件捕获模式 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 只当在event.target是当前元素自身时触发处理函数 即事件不是从内部元素触发的 点击事件将只会触发一次 不像其他只能对原生的DOM事件起作用的修饰符，.once修饰符还能被用到自定义的组件事件上 Vue还对应addEventListener中的passive选项提供了.passive修饰符 滚动事件的默认行为将会立即触发 而不会等待onScroll完成 这其中包含event.preventDefault()的情况 这个.passive修饰符能提升移动端的性能 不要把.passive和.prevent一起使用，因为.prevent将会被忽略，同时浏览器可能会向你展示一个警告， 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生，因此，用v-on:click.prevent.self会阻止所有的点击。而v-on:click.self.prevent只会阻止对元素自身的点击 按键修饰符 在监听键盘事件时，我们经常需要检查详细的按键。Vue允许为v-on在监听键盘事件时添加按键修饰符 只有在'key'是'Enter'时调用'vm.submit()' 也可以直接将KeyboardEvent.key暴露的任意有效按键名转换为kebab-case 来作为修饰符 在上述实例中，处理函数只会在$event.key等于PageDown时被调用 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器 .ctrl .alt .shift .meta .exact修饰符 .exact修饰符允许你控制由精确的系统修饰符组合触发的事件 即使alt或shift被一同按下时也会触发 a 有且只有Ctrl被按下的时候才触发 A 没有任何系统修饰符被按下的时候才触发 A 鼠标按钮修饰符 .left .right .middle 为什么在HTML中监听事件？ 你可能注意到这种事件监听的方式违背了关注点分离这个长期以来的优良传统。但不必担心，因为所有vue.js事件处理方法和表达式都严格绑定在当前视图的ViewModel上，它不会导致任何维护上的困难。实际上，使用v-on有几个好处 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法 因为你无须在 JavaScript 里手动绑定事件，你的ViewModel 代码可以是非常纯粹的逻辑，和DOM完全解耦，更易于测试 当一个 ViewModel 被销魂时，所有的事件处理器都会自动被删除。你无须担心如何清理他们 表单输入绑定 基础用法 你可以用v-model指令在表单input、textarea及select元素上创建双向数据绑定，他会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但v-modal本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 v-modal会忽略所有表单元素的value、checked、selected attribute的初始值而总是将Vue实例的数据作为数据来源，应该通过JavaScript在组件的data选项中声明初始值。 v-modal在内部为不同的输入元素使用不同的property并抛出不同的事件： text和textarea元素使用value property 和 input事件 checkbox和radio使用checked property 和 change事件 select字段将value作为prop并将change作为事件 对于需要使用输入法的语言，会发现v-modal不会再输入法组合文字过程中得到更新。如果想处理这个过程，使用input事件 文本 Message is : {{message}} 多行文本 Multiline message is : {{message}} 复选框 单个复选框，绑定到布尔值 {{checked}} 值绑定 对于单选按钮，复选框及选择框的选项，v-model绑定的值通常是静态字符串(对于复选框也可以是布尔值) 当选中时,picked为字符串'a' toggle为true为false 当选中第一个选项时，selected为字符串abc ABC 但是有时我们可能想把值绑定到Vue实例的一个动态property上，这是可以用v-bind实现，并且这个property的值可以不是字符串 这里的true-value和false-value attribute并不会影响输入控件的value attribute，因为浏览器再提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，即'yes'或'no',请换用单选按钮 修饰符 .lazy 在默认情况下，v-model在每次input事件触发后将输入框的值与数据进行同步（除了输入法组合文字）。你可以添加lazy修饰符，从而转为在change事件之后进行同步 .number 如果想自动将用户的输入值转为数值类型，可以给v-model添加number修饰符 这通常很有用，因为即使在type=\"number\"时,HTML输入元素的值也总会返回字符串。如果这个值无法被parseFloat()解析，则会返回原始的值。 .trim 如果要自动过滤用户输入的首尾空白字符，可以给v-model添加trim修饰符 组件基础 // 定义一个名为 button-counter 的新组件 Vue.component('button-counter', { data: function () { return { count: 0 } }, template: 'You clicked me {{ count }} times.' }) 组件是可复用的Vue实例，且带有一个名字：在这个例子中是button-counter 我们可以在一个通过new Vue创建的Vue实例中，把这个组件作为自定义元素来使用 new Vue({el:'#components-demo'}) 因为组件是复用的Vue实例，所以它们与new Vue接受相同的选项，例如data、computed、watch、methods以及生命周期钩子等。 组件的复用 可以将组件进行任意次数的复用 注意点击按钮时，每个组件都会各自独立维护它的count，因为你没用一次组件，就会有一个它的新实例被创建 data 必须是一个函数 当我们定义这个button-counter组件时，你可能会发现它的data并不是像这样直接提供一个对象 data : { count:0 } 取而代之的是，一个组件的data选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝 data:function(){ return { count:0 } } 组件的组织 通常一个应用会一棵嵌套的组件树的形式来组织 例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其他的像导航链接、博文之类的组件 为了能在模板中使用，这些组件必须先注册以便Vue能够识别。这里有两种组件的注册类型：全局注册和局部注册。至此，我们的组件都只是通过Vue.component全局注册的 Vue.component('my-component-name',{ }) 全局注册的组件可以用在其被注册之后的任何（通过 new Vue）新创建的Vue实例，也包括其组件树中的所有子组件的模板中 通过prop向子组件传递数据 早先时候，我们提到了创建一个博文组件的问题。问题是如果你不能向这个组件传递某一篇博文的标题或内容之类的我们想展示的数据的话，它是没有办法使用的。这也是prop的由来 prop是你可以在组件上注册的一些自定义的attribute。当一个值传递给一个prop attribute的时候，它就变成了那个组件实例的一个property。为了给博文组件传递一个标题，我们可以用一个props选项将其包含在该组件可接受的prop列表中 Vue.component('blog-post',{ props:['title'], template:'{{title}}' }) 一个组件默认可以拥有任意数量的prop，任何值都可以传递给任何prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问data中的值一样。 一个prop被注册之后，你就可以像这样把数据作为一个自定义attribute传递进来 然而在一个典型的应用里，你可能在data里有一个博文的数组 new Vue({ el:'#blog-post-demo', data:{ posts:[ {id:1,title:'My journey with Vue'}, {id:2,title:'Blogging wite vue'}, {id:3,title:'Why Vue is so fun'} ] } }) 如上所示，你会发现我们可以使用v-bind来动态传递prop。这在你一开始不清楚要渲染的具体内容，比如从一个API获取博文列表的时候，是非常有的 单个根元素 当构建一个blog-post组件时，你的模板最终会包含的东西远不止一个标题 当组件变得越来越复杂的时候，我们的博文不只需要标题和内容，还需要发布日期、评论等等。为每个相关的信息定义一个prop会变得很麻烦 重构blog-post组件，让它接受一个单独的post prop: Vue.component('blog-post',{ props:['post'], template:' {{post.title}} ' }) 监听子组件事件 在我们开发blog-post组件时，他的一些功能可能要求我们和父级组件进行沟通。例如我们可能会引入一个辅助功能来放大博文的字号，同时让页面的其他部分保持默认的字号 在其父组件中，我们可以通过添加一个postFontSize数据property来支持这个功能 new Vue({ el:'#blog-posts-events-demo', data:{ post:[], postFontSize:1 } }) 使用事件抛出一个值 有的时候用一个事件来抛出一个特定的值是非常有用的，例如我们可能想然blog-post组件决定他的文本要放大多少，这时可以使用$emit的第二个参数来提供这个值 Enlarge text 在组件上使用v-model 自定义事件也可以用于创建支持的v-model的自定义输入组件 //等价于 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/interview/":{"url":"chapters/interview/","title":"面试","keywords":"","body":"面试 记录 先占个坑位,记录面试 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/written/":{"url":"chapters/written/","title":"笔试","keywords":"","body":"笔试记录 记录笔试中的问题 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/test/":{"url":"chapters/test/","title":"期末复习","keywords":"","body":"期末复习笔记 powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chapters/test/rn.html":{"url":"chapters/test/rn.html","title":"react-native","keywords":"","body":"react-native复习 创建项目 npx react-native init ProjectName 运行项目 react-native run-android 连接设备 adb devices 常用组件 View Text 元素在布局上不同于其他组件，在Text内部的元素不再使用flexbox布局，而是采用文本布局 Image 显示不同类型图片的组件，包括网络图片、静态资源、base64图片 //本地图片 //线上图片 //base64图片 resizeMode : 决定当组件尺寸和图片尺寸不成比例的时候如何调整图片的大小，默认值是cover. cover:在保持图片宽高比的前提下缩放图片，直到宽度和高度都大于等于容器视图的尺寸。 contain:在保持图片宽高比的前提下缩放图片，直到宽高都小于等于容器视图的尺寸。 stretch:宽高填满容器 repeat:重复平铺图片直到填满容器。图片会维持原始尺寸，但是当尺寸超过容器时会在保持宽高比的前提下缩放到能被容器包裹 center:居中不拉伸 ImageBackground 添加背景，必须指定width和height TextInput ScrollView 滚动组件 交互组件 Button 跨平台的按钮组件 {}} title='按钮' /> TouchableOpacity 可以自己定制的按钮 列表组件 FlatList 特点: 完全跨平台 支持水平布局 支持单独的头部尾部组件 支持下拉刷新，上拉加载 onRefresh onEndReached 支持跳转到指定行 支持多列布局 行组件显示或隐藏时可配置回调事件 {item.key}} /> 记 onRefresh：下拉刷新 refreshing：下拉刷新时的图标 onEndReached: 上拉加载 onEndReachedThreshold: （0-1之间的数）距离底部多少距离触发上拉加载函数 keyExtractor: 为 item 指定key SectionList 高性能的分组列表组件 item+index} renderItem={(item)=>} renderSectionHeader={({ section: { title } }) => ( {title} )} /> 路由组件 react-navigation react-native-router-flux 基础使用 const Root = () => { return ( {/*Router 里只能放一个组件，将全部的跳转页面都放到Root下面*/} {/*key 就是给页面的标签，供Actions使用*/} {/*component 设置关联的页面*/} {/*title 页面标题*/} {/*initial 设置默认页面*/} ) } 路由跳转 const PageOne = () => { return ( Actions.two()}> 我是Page One ) } 数据传递和刷新 export default class PageTwo extends Component { render() { const data = this.props.data || 'null'; return ( {()=>Actions.one({ data:'从two传递到one' })} 我是Page One Actions.refresh({ data:'Changed data' })}> refresh:{data} ) } } Tabs功能 const Root = () => { return ( ) } Drawer Lightbox ... Modal ... 其他组件 Animated 创建动画 WebView react-native-image-picker 启动本地图库和照相机来采集图片 react-native-image-crop-picker 启动本地图库和照相机来采集图片并且可以裁剪 react-native-button react-native-message-bar 消息栏通知组件 react-native-vector-icons 图标库 react-native-swiper 轮播图 获取设备尺寸 Dimensions.get('window').width flex布局 flexDirection justifyConent alignItems 本地存储 AsyncStorage.setItem('username','zhangsan',()=>console.log('store success!')) AsyncStorage.getItem('username') powered by Gitbook该文件最后修改时间： 2020-12-22 07:55:02 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}